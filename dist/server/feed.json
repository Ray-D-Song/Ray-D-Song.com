{
    "version": "https://jsonfeed.org/version/1",
    "title": "Ray-D-Song",
    "home_page_url": "https://ray-d-song.com/",
    "feed_url": "https://ray-d-song.com/feed.json",
    "description": "Ray's blog, Just for fun",
    "icon": "https://ray-d-song.com/avatar.jpeg",
    "author": {
        "name": "Ray-D-Song",
        "url": "https://ray-d-song.com"
    },
    "items": [
        {
            "content_html": "<p>Vue macro(宏) 随着<code>&lt;script setup&gt;</code>写法一同引入 Vue 生态, 进一步丰富了 Vue 在编译期的想象力.<br>\n本文主要分析 Vue defineProps 的 type-only 写法是如何根据类型信息生成运行时代码.</p>\n<p>我们先拉取 Vue 的源代码, 并切换到3.0.3版本, 这是最早引入 script setup 和 defineProps macro 的版本.</p>\n<p>Vue 的 script setup 编译器源码位于<code>packages/compiler-sfc/src/compileScript.ts</code>, 接下来所有的代码都出自这个文件</p>\n<p>为了方便查看运行结果和打印, 在根目录下的<code>package.json</code>新增<code>test-compiler</code>命令, 这条命令表示只运行<code>packages/compiler-sfc</code>文件夹下的<code>with TypeScript</code>测试.</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;test-compiler&quot;: &quot;jest packages/compiler-sfc --testPathPattern='packages/compiler-sfc' --testNamePattern='with TypeScript' &quot;,\n  },\n</code></pre>\n<p>先看 defineProps&lt;{}&gt;() 会被编译成什么<br>\n在<code>packages/compiler-sfc/__tests__/compileScript.spec.ts</code>文件的451 行打个<code>console.log(content)</code>, 查看编译完成的内容<br>\n输入:</p>\n<pre><code class=\"language-typescript\">import { defineProps } from 'vue'\n\n\ndefineProps&lt;{\n  string: string\n  number: number\n  boolean: boolean\n  object: object\n  // ...\n}&gt;()\n</code></pre>\n<p>输出:</p>\n<pre><code class=\"language-typescript\">import { defineComponent as _defineComponent } from 'vue'\n\n\nexport default _defineComponent({\n  expose: [],\n  props: {\n    string: { type: String, required: true },\n    number: { type: Number, required: true },\n    boolean: { type: Boolean, required: true },\n    object: { type: Object, required: true },\n    // ...\n  } as unknown as undefined,\n  setup(__props: {\n        string: string\n        number: number\n        boolean: boolean\n        object: object\n        // ...\n      }) {\n\nreturn {  }\n}\n\n})\n</code></pre>\n<p>可以看到 defineProps 被编译为<code>defineComponent</code>方法中的 options props 写法, 同时还定义了 defineComponent 方法中的 setup 函数选项并保留了类型的定义.</p>\n<h2>定位</h2>\n<p>在<code>packages/compiler-sfc/src/compileScript.ts</code>文件中, 我们一眼能找到一个看起来是处理 props 的方法:</p>\n<pre><code class=\"language-typescript\">function processDefineProps(node: Node): boolean {\n  if (isCallOf(node, DEFINE_PROPS)) {\n    hasDefinePropsCall = true\n    // context call has type parameters - infer runtime types from it\n    if (node.typeParameters) {\n      const typeArg = node.typeParameters.params[0]\n      if (typeArg.type === 'TSTypeLiteral') {\n        propsTypeDecl = typeArg\n      }\n    }\n    return true\n  }\n  return false\n}\n</code></pre>\n<p>这个函数接受参数<code>node</code>, 并将propsTypeDecl赋值为 node.typeParameters.params[0]<br>\n接下来我们按照看源码的惯例: 向前找入参 node, 向后找 propsTypeDecl 的作用.</p>\n<h2>向前看: node 是什么, 从哪来</h2>\n<p>我们在 processDefineProps 方法中打印一下 node:</p>\n<pre><code class=\"language-typescript\">Node {\n  type: 'CallExpression',\n  start: 101,\n  end: 732,\n  loc: SourceLocation {\n    start: Position { line: 7, column: 6 },\n    end: Position { line: 30, column: 10 },\n    filename: undefined,\n    identifierName: undefined\n  },\n  range: undefined,\n  leadingComments: undefined,\n  trailingComments: undefined,\n  innerComments: undefined,\n  extra: undefined,\n  callee: Node {\n    type: 'Identifier',\n    start: 101,\n    end: 112,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: 'defineProps'\n    },\n    range: undefined,\n    leadingComments: undefined,\n    trailingComments: undefined,\n    innerComments: undefined,\n    extra: undefined,\n    name: 'defineProps'\n  },\n  arguments: [],\n  typeParameters: Node {\n    type: 'TSTypeParameterInstantiation',\n    start: 112,\n    end: 730,\n    loc: SourceLocation {\n      start: [Position],\n      end: [Position],\n      filename: undefined,\n      identifierName: undefined\n    },\n    range: undefined,\n    leadingComments: undefined,\n    trailingComments: undefined,\n    innerComments: undefined,\n    extra: undefined,\n    params: [ [Node] ]\n  }\n}\n</code></pre>\n<p>熟悉 babel 的哥们应该一眼能看出这是 babel 的 AST(抽象语法树).</p>\n<blockquote>\n<p>抽象语法树可以简单理解为分析源代码产生的相关信息<br>\n我们继续找, 看看是哪里提供了这个 node.<br>\n在 552 行, 我们可以找到 node 是 scriptSetupAst 的遍历子节点</p>\n</blockquote>\n<pre><code class=\"language-typescript\">// line 552\nfor (const node of scriptSetupAst)\n</code></pre>\n<p>而 <code>scriptSetupAst</code> 是调用了 parse 函数, 传入了<code>&lt;script setup&gt;</code>标签内的内容</p>\n<pre><code class=\"language-typescript\">// parse &lt;script setup&gt; and  walk over top level statements\nconst scriptSetupAst = parse(\n  scriptSetup.content,\n  {\n    plugins: [\n      ...plugins,\n    ],\n    sourceType: 'module'\n  },\n  startOffset\n)\n</code></pre>\n<p>继续寻找 parse 函数的定义, 在 209 行.<br>\nparse 函数调用了_parse 函数, 而 _parse 函数是<code>@babel/parser</code>包中 parse 函数的别名, 该函数返回的就是 Babel AST 格式的 AST, 证实了之前的猜想</p>\n<pre><code class=\"language-typescript\">function parse(\n  input: string,\n  options: ParserOptions,\n  offset: number\n): Statement[] {\n  try {\n    return _parse(input, options).program.body\n  } catch (e) {\n    ...\n  }\n}\n</code></pre>\n<p>到这里, 「向前看」的工作已经完成, 大体流程为<br>\n<img src=\"https://r2.ray-d-song.com/2024/02/2101e0b9f3936ba65773c8f9a77e3db2.png\" alt=\"half\"></p>\n<h2>向后看: propsTypeDecl 有什么用, 怎么处理</h2>\n<p>processDefineProps 的作用是对 propsTypeDecl 赋值, 那么赋值后对 propsTypeDecl 进行了哪些操作就是生成运行时 props 定义的关键.<br>\n按照惯例, 首先打印 propsTypeDecl</p>\n<pre><code class=\"language-typescript\">propsTypeDecl:  Node {\n  type: 'TSTypeLiteral',\n  start: 113,\n  end: 729,\n  loc: SourceLocation {\n    start: Position { line: 7, column: 18 },\n    end: Position { line: 30, column: 7 },\n    filename: undefined,\n    identifierName: undefined\n  },\n  range: undefined,\n  leadingComments: undefined,\n  trailingComments: undefined,\n  innerComments: undefined,\n  extra: undefined,\n  members: [\n    Node {\n      type: 'TSPropertySignature',\n      start: 123,\n      end: 137,\n      loc: [SourceLocation],\n      range: undefined,\n      leadingComments: undefined,\n      trailingComments: undefined,\n      innerComments: undefined,\n      extra: undefined,\n      key: [Node],\n      computed: false,\n      typeAnnotation: [Node]\n    },\n    Node {\n      type: 'TSPropertySignature',\n      start: 146,\n      end: 160,\n      loc: [SourceLocation],\n      range: undefined,\n      leadingComments: undefined,\n      trailingComments: undefined,\n      innerComments: undefined,\n      extra: undefined,\n      key: [Node],\n      computed: false,\n      typeAnnotation: [Node]\n    },\n    Node {\n      type: 'TSPropertySignature',\n      start: 169,\n      end: 185,\n      loc: [SourceLocation],\n      range: undefined,\n      leadingComments: undefined,\n      trailingComments: undefined,\n      innerComments: undefined,\n      extra: undefined,\n      key: [Node],\n      computed: false,\n      typeAnnotation: [Node]\n    },\n    ...\n  ]\n}\n</code></pre>\n<p>可以看到, propsTypeDecl 就是 defineProps 类型声明的 AST. 主要内容是<code>members</code>字段, 每一个Node对应着一个 props 元素声明</p>\n<p>接下来我们找哪里使用了这个<code>propsTypeDecl</code></p>\n<p>propsTypeDecl 有两处引用</p>\n<h3>生成运行时props(重点)</h3>\n<pre><code class=\"language-typescript\">// 4. extract runtime props/emits code from setup context type\nif (propsTypeDecl) {\n  extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes)\n}\n</code></pre>\n<p>参数除了 propsTypeDecl 之外, 还有</p>\n<ul>\n<li>typeDeclaredProps: 类型定义为<code>Record&lt;string, string[]&gt;</code>, 默认为{}的变量</li>\n<li>declaredTypes: 类型<code>Record&lt;string, string[]&gt;</code>, 默认{}的变量</li>\n</ul>\n<p>接下来看看这个函数都做了啥操作</p>\n<pre><code class=\"language-typescript\">function extractRuntimeProps(\n  node: TSTypeLiteral,\n  props: Record&lt;string, PropTypeData&gt;,\n  declaredTypes: Record&lt;string, string[]&gt;\n) {\n  // members 即 literal type 的AST数组\n  for (const m of node.members) {\n    // 判断是否为 literal type\n    if (m.type === 'TSPropertySignature' &amp;&amp; m.key.type === 'Identifier') {\n      // 为 typeDeclaredProps 添加字段\n      props[m.key.name] = {\n        key: m.key.name,\n        required: !m.optional,\n        type:\n          // dev 下生成 type 字段, 生产环境不需要类型信息, 直接赋值 null\n          __DEV__ &amp;&amp; m.typeAnnotation\n            ? inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes)\n            : [`null`]\n      }\n    }\n  }\n}\n</code></pre>\n<p>该函数的作用就是根据 AST 的信息生成运行时的 props 声明, 并赋值给第二个参数<code>typeDeclaredProps</code>, 这个参数最终就是编译完成的 Props.<br>\n这里还调用了<code>inferRuntimeType</code>方法, 方法主体就是 switch 语句, 根据不同的<code>node.type</code>字段返回不同的运行时类型声明<br>\n截取其中一小段:</p>\n<pre><code class=\"language-typescript\">switch (node.type) {\n  case 'TSStringKeyword':\n    return ['String']\n  case 'TSNumberKeyword':\n    return ['Number']\n</code></pre>\n<h3>生成 __props 字段</h3>\n<p>propsTypeDecl 另一处引用是用来生成<code>defineProps</code>方法中的__props字段:</p>\n<pre><code class=\"language-typescript\">// 9. finalize setup() argument signature\nlet args = `__props`\nif (propsTypeDecl) {\n  args += `: ${scriptSetup.content.slice(\n    propsTypeDecl.start!,\n    propsTypeDecl.end!\n  )}`\n}\n// inject user assignment of props\n// we use a default __props so that template expressions referencing props\n// can use it directly\nif (propsIdentifier) {\n  s.prependRight(startOffset, `\\nconst ${propsIdentifier} = __props`)\n}\nif (emitIdentifier) {\n  args +=\n    emitIdentifier === `emit` ? `, { emit }` : `, { emit: ${emitIdentifier} }`\n  if (emitTypeDecl) {\n    args += `: {\n      emit: (${scriptSetup.content.slice(\n        emitTypeDecl.start!,\n        emitTypeDecl.end!\n      )}),\n      slots: any,\n      attrs: any\n    }`\n  }\n}\n</code></pre>\n<h2>总结</h2>\n<p>到这里我们分析完了整个的流程, 如下:<br>\n<img src=\"https://r2.ray-d-song.com/2024/02/4feb8aaf8c3cda71a6383100a72cb3e2.png\" alt=\"full flow\"></p>\n",
            "url": "https://ray-d-song.com/post/vue-compiler-macro-defineprops",
            "title": "Vue 宏编译: 以 defineProps 为例",
            "date_modified": "2024-02-28T16:00:00.000Z",
            "author": {
                "name": "Ray-D-Song",
                "url": "https://ray-d-song.com"
            }
        },
        {
            "content_html": "<h1>单元测试的定义</h1>\n<blockquote>\n<p>本文源码: <a href=\"https://github.com/Ray-D-Song/vitest-tutorial-sourcecode\">https://github.com/Ray-D-Song/vitest-tutorial-sourcecode</a></p>\n</blockquote>\n<blockquote>\n<p>单元测试（英语：Unit Testing）又称为模块测试 [来源请求] ，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。     ———wiki</p>\n</blockquote>\n<p>在一个典型的 Vue 项目中, 我们经常需要进行单元测试的模块包括以下几种:</p>\n<ul>\n<li>hooks</li>\n<li>工具函数 (utils)</li>\n<li>校验规则 (reg)</li>\n<li>脚手架 (bin/scaffold)</li>\n<li>自定义 vue 指令</li>\n<li>全局状态 (store)</li>\n</ul>\n<h1>初始化 Vitest</h1>\n<p>安装 Vitest</p>\n<pre><code class=\"language-bash\">pnpm add -D vitest\n</code></pre>\n<p>Vitest 默认和 Vite 配置集成, 不需要额外的配置文件.<br>\n修改<code>package.json</code>, 在<code>script</code>下新增<code>test:unit</code>命令</p>\n<pre><code class=\"language-json\">  &quot;scripts&quot;: {\n    ...\n    &quot;test:unit&quot;: &quot;vitest&quot;,\n  },\n</code></pre>\n<h1>编写测试用例</h1>\n<p>测试一个手机号校验函数</p>\n<pre><code class=\"language-ts\">/** /reg/phone.ts */\n// 校验是否国内手机号\nexport function regChinesePhoneNumber(phoneNumber: string) {\n  const regex = /^1[3456789]\\d{9}$/\n  return regex.test(phoneNumber)\n}\n\n/** /reg/phone.test.ts */\nimport { describe, expect, test } from 'vitest'\nimport { regChinesePhoneNumber } from '../phone'\n\ndescribe('phone', () =&gt; {\n  test('phone number belongs to Chinese', () =&gt; {\n    expect(regChinesePhoneNumber('17725663831')).toBe(true)\n  })\n})\n</code></pre>\n<p>输入命令<code>npm run test:unit</code>, 不出意外你会看到以下内容, 表明测试通过:<br>\n<img src=\"https://r2.ray-d-song.com/202312071947299.png\" alt=\"test result\"></p>\n<p>编写测试的代码文件通常放置在<code>__test__</code>文件夹中, 命名为<code>xxx.test.ts</code>或<code>xxx.spec.ts</code>, Vitest 会自动运行所有此类命名的文件.<br>\n编写测试的基础是<code>describe、test、expect</code>关键字.<br>\n<code>describe</code> 用于定义一个测试<code>套件</code>, 套件类似于 js 的模块, 用于将多个 test 封装到一起, 搭配<code>skip、only</code>等 api 可以实现选择性测试等功能.<br>\n<code>test</code> 用于声明一个测试, 接收测试名称和保存测试期望的函数.<br>\n<code>expect</code> 用于设置断言, Vitest 默认提供基于<code>chai</code>的断言, 你不知道什么是 chai 没关系, 断言是单元测试的关键助手, 后面会详细介绍</p>\n<h1>实践</h1>\n<p>接下来, 我们对几种常见的场景进行单测</p>\n<h2>hooks</h2>\n<p>hooks 是逻辑的封装, 是最需要单测的场景.<br>\n编辑器和表单有一个常见需求是记录上一次更改时间, 我们可以通过几行代码封装一个 hooks.</p>\n<pre><code class=\"language-ts\">/** /src/hooks/useLastChange.ts */\nimport { watch, ref, type WatchSource } from 'vue'\nimport moment from 'moment/moment'\n\nexport function useLastChange(source: WatchSource) {\n  const lastChange = ref('')\n\n  watch(source, () =&gt; {\n    lastChange.value = moment().format('YYYY-MM-DD HH:mm:ss')\n  })\n\n  return lastChange\n}\n\n/** /src/hooks/__test__/useLastChange.test.ts */\nimport { expect, it } from 'vitest'\nimport { nextTick, ref } from 'vue'\nimport { useLastChange } from '../useLastChange'\n\nit('update lastChange when source changes', async () =&gt; {\n  const source = ref('')\n  const lastChange = useLastChange(source)\n  const snapShot01 = lastChange.value\n  source.value = 'Ray'\n  await nextTick()\n  const snapShot02 = lastChange.value\n\n  expect(snapShot01).not.toBe(snapShot02)\n})\n</code></pre>\n<p>hooks 的测试比较简单, 就是执行后比对结果. utils 和 reg 也是类似, 此处略过.</p>\n<h2>scaffold</h2>\n<p>脚手架一般是框架自身提供的命令行工具, 用于生成模板代码, 放置于 bin 目录.<br>\nVue 和 React 自身只提供了创建项目工具, 没有提供类似 Rails Command Line 的项目搭建工具. 因此前端spa项目的脚手架都是自己针对常见业务场景的封装.<br>\n脚手架一般通过 npm 命令执行, 在 package.json 中添加一条命令</p>\n<pre><code class=\"language-json\">&quot;create&quot;: &quot;node ./bin/create.js --type=$npm_config_type --path=$npm_config_path\n</code></pre>\n<p>运行<code>npm run create --type=table --path='/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/views/TestTable.vue' </code>, 就会执行 /bin/index 脚本中的内容并将 type 和 path 值作为参数传递.<br>\n编写 create 脚本:</p>\n<pre><code class=\"language-js\">/** /src/bin/create.js */\nimport minimist from 'minimist'\nimport { readFileSync, writeFileSync } from 'fs'\n\nfunction main() {\n  // 使用 minimist 处理参数\n  const args = minimist(process.argv.slice(2))\n  const { type, path } = args\n  let temp = ''\n  if(type === 'table') {\n    temp = readFileSync('./src/bin/dist/table', 'utf-8') \n  }\n  writeFileSync(path, temp)\n  console.log('\\n创建完成')\n}\n\nmain()\n</code></pre>\n<p>脚手架其实只进行 3 个操作, 获取参数, 读取对应的模板, 创建目标文件.<br>\nvitest 和 jest 并没有比较好的执行 npm 命令的方法, 因此我们要对上面的方法稍加改造:</p>\n<pre><code class=\"language-js\">/** /src/bin/create.js */\nimport { readFileSync, writeFileSync } from 'fs'\n\nfunction create(args) {\n  const { type, path } = args\n  let temp = ''\n  if(type === 'table') {\n    temp = readFileSync('./src/bin/dist/table', 'utf-8') \n  } else {\n    throw '当前仅支持生成 table 类型'\n  }\n  writeFileSync(path, temp)\n  console.log('\\n创建完成')\n}\n\nexport default create\n\n/** /src/bin/index.js */\nimport create from './create'\n\n// 使用 minimist 处理参数\nconst args = minimist(process.argv.slice(2))\ntry {\n  create(args)\n} catch(e) {\n  console.log(e)\n}\n</code></pre>\n<p>将脚本入口和执行方法分离是为了防止 unit test 过程中自动执行 main 方法报错.<br>\n接下来我们就可以在 test 中导入 create 方法进行测试. 断言可以通过读取生成的模板内容和 table 文件中内容进行比较.<br>\n以下是测试用例, 从参数、生成内容进行测试</p>\n<pre><code class=\"language-ts\">/** /src/bin/__test__/create.test.ts */\nimport create from '../create'\nimport { describe, expect, it } from 'vitest'\nimport { readFileSync } from 'fs'\n\ndescribe('bin scaffold module', () =&gt; {\n\n  describe('create table error args', () =&gt; {\n    it('error temp type', () =&gt; {\n      try {\n        create({\n          type: 'dialog',\n          path: '/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/dialog.vue'\n        })\n      } catch(e) {\n        expect(e).toBe('当前仅支持生成 table 类型')\n        const product = readFileSync('/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/dialog.vue', 'utf-8')\n        expect(product).toBeUndefined\n      }\n    })\n  })\n\n  it('create table', () =&gt; {\n    create({\n      type: 'table',\n      path: '/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/table.vue'\n    })\n    const temp = readFileSync('/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/dist/table', 'utf-8')\n    const product = readFileSync('/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/table.vue', 'utf-8')\n    expect(temp).toBe(product)\n  })\n\n})\n</code></pre>\n<p><img src=\"https://r2.ray-d-song.com/202312121120257.png\" alt=\"result\"></p>\n<h2>自定义 Vue 指令</h2>\n<p>自定义一个 v-debounce, 用于给按钮增加防抖效果</p>\n<pre><code class=\"language-ts\">import _ from 'lodash'\n\nconst vDebounce = {\n  beforeMount(el: HTMLElement, binding: {value: () =&gt; void}) {\n    el.addEventListener('click', _.debounce(binding.value, 600))\n  }\n}\n\napp.directive('debounce', vDebounce)\n</code></pre>\n<p>为了测试这个指令, 我们需要模拟<code>组件挂载-&gt;用户点击-&gt;方法调用的过程</code>, 也就是我们需要调用部分组件测试的能力. <code>@vue/test-utils</code> 是常用的 Vue 组件测试库.</p>\n<pre><code class=\"language-bash\">pnpm install @vue/test-utils\n</code></pre>\n<p>vue-test-utils 兼容 jest 和 Vitest, 安装后可以直接使用. 下面是自定义指令的功能测试:</p>\n<pre><code class=\"language-ts\">/** /src/utils/__test__/directives.test.ts */\nimport { describe, expect, it } from 'vitest'\nimport { defineComponent, nextTick, ref } from 'vue'\nimport { mount } from '@vue/test-utils'\nimport { vDebounce } from '../directives'\n\n// 使用 defineComponent 定义测试组件\n// 该 api 除了 template 作为字符串传递外\n// 还可以使用 tsx 获得更好的代码提示\nconst tc = defineComponent({\n  setup() {\n    const num = ref(0)\n    function add() {\n      num.value++\n    }\n    return {\n      num,\n      add  \n    }\n  },\n  template: '&lt;button v-debounce=&quot;add&quot;&gt;num: {{num}}&lt;/button&gt;'\n})\n\ndescribe('custom directives', async () =&gt; {\n  // vue-test-utils 的 mount api, 将组件实例化\n  it('debounce submit', async () =&gt; {\n    const wrapper = mount(tc, {\n      global: {\n        directives: {\n          debounce: vDebounce\n        }\n      }\n    })\n\n    // 每过 200 毫秒点击一次 button\n    const interval = setInterval(async () =&gt; {\n      // find api 查找目标元素\n      await wrapper.find('button').trigger('click')\n    }, 200)\n    // 阻塞 1000 秒, 让点击事件在 1 秒内执行 4 次\n    await new Promise(resolve =&gt; setTimeout(resolve, 1000))\n\n    clearInterval(interval)\n\n    // 阻塞 700 秒, 等待函数执行\n    await new Promise(resolve =&gt; setTimeout(resolve, 700))\n    // 确保组件重新渲染\n    await nextTick()\n    // 获取目标元素\n    const btn = wrapper.get('button')\n    // 对目标元素的文本进行断言\n    expect(btn.text()).toBe('num: 1')\n  })\n})\n</code></pre>\n<h2>store</h2>\n<p>大型的前端项目基本都会用到全局的状态管理库, Vue3 最流行的是 Pinia.<br>\nPinia 提供了可用于测试的 api.</p>\n<pre><code class=\"language-ts\">import { createPinia, setActivePinia } from 'pinia'\nimport { beforeEach, describe, expect, it } from 'vitest'\nimport { useCounterStore } from '../counter'\n\ndescribe('Counter Store', () =&gt; {\n  beforeEach(() =&gt; {\n    setActivePinia(createPinia())\n  })\n\n  it('increments', () =&gt; {\n    const counter = useCounterStore()\n    expect(counter.count).toBe(0)\n    counter.increment()\n    expect(counter.count).toBe(1)\n  })\n})\n</code></pre>\n<p>这里引入了一个新的 api: <code>beforeEach</code>, 这是一种<code>测试生命周期钩子</code>, 传入的方法在每个测试用例之前执行.<br>\n我们传入了 pinia 的 <code>setActivePinia</code> api, 这是个 SSR 经常使用的 api, 用户设置一个激活的 Pinia 实例.</p>\n<h1>断言</h1>\n<p>断言是单元测试的核心, 本质一堆用来判断结果的函数库.<br>\n在上面的例子, 我们使用了<code>toBe</code>断言, 这是最常用的断言, 该断言用于判断值相等或者相同引用, 类似于<code>Object.is</code>.<br>\n以下为常用的几种断言:</p>\n<table>\n<thead>\n<tr>\n<th>断言</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>not</td>\n<td>取反</td>\n</tr>\n<tr>\n<td>toBe</td>\n<td>判断值或对象引用是否相同</td>\n</tr>\n<tr>\n<td>toEqual</td>\n<td>判断对象值是否相同</td>\n</tr>\n<tr>\n<td>toBeGreaterThan</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>toBeGreaterThanOrEqual</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>toBeLessThan</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>toBeLessThanOrEqual</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>soft</td>\n<td><code>expect.soft</code> 遇到某条用例失败也不会停止测试, 直到所有用例执行完毕展示所有错误</td>\n</tr>\n<tr>\n<td>toBeTypeOf</td>\n<td>断言类型是否相同</td>\n</tr>\n<tr>\n<td>toBeInstanceOf</td>\n<td>判断是否是目标类的实例</td>\n</tr>\n<tr>\n<td>toStrictEqual</td>\n<td>严格相等, 会检查具有 undefined 属性的 key、数组稀疏性、对象类型是否相等</td>\n</tr>\n<tr>\n<td>toContain</td>\n<td>检查数组元素和子串</td>\n</tr>\n<tr>\n<td>toThrowError</td>\n<td>检查函数调用过程中是否报错</td>\n</tr>\n<tr>\n<td>resolves</td>\n<td><code>expect(func()).resolves.toEqual</code></td>\n</tr>\n<tr>\n<td>rejects</td>\n<td><code>expect(func()).rejects.toThrow</code></td>\n</tr>\n</tbody>\n</table>\n<h1>mock</h1>\n<p>为了应对业务耦合, 做到仅测试功能代码, 我们可以使用 mock 工具进行数据模拟.<br>\n最常见的场景是模拟请求, 一般情况下你可以自己用一个 Promise 来模拟请求结果, 但有些情况也许你需要更真实的场景.<br>\n常用的 mock 工具, 例如 APIfox, 是通过接口定义来「启动一个真实的服务器返回假数据」. 而 Vitest 并不会启动真正的 node 服务器, 而是通过<code>mswjs</code>来拦截对应地址的请求.<br>\n也就是说你可以很方便的去模拟「异常请求」的场景.<br>\n首先安装 msw: <code>pnpm install msw</code></p>\n<p>假设我们需要请求<code>https://thorn.mock/test</code>这个接口, 获取<code>{msg: 'hey'}</code>的 json 数据, 以下是我们的测试用例.</p>\n<pre><code class=\"language-ts\">/** /src/api/__test__/mock.test.ts */\nimport { describe, expect, it } from 'vitest'\n\ndescribe('mock', async () =&gt; {\n  it('mock api', async () =&gt; {\n    const response = await fetch('https://thorn.mock/test') \n    // 使用 toEqual 来比较对象值\n    expect(await response.json()).toEqual({\n      msg: 'hey'\n    })\n  })\n})\n</code></pre>\n<p>为了 mock 这个接口, 我们需要按照 msw 的语法编写一个 server.</p>\n<pre><code class=\"language-ts\">/** /src/mocks/server.ts */\nimport { setupServer } from 'msw/node'\nimport { HttpHandler, HttpResponse, http } from 'msw'\n\nexport const handlers: Array&lt;HttpHandler&gt; = [\n  http.get('https://thorn.mock/test', () =&gt; {\n    return HttpResponse.json({\n      msg: 'hey'\n    })\n  })\n]\n\nexport const server = setupServer(...handlers)\n</code></pre>\n<p>理想状况下, 我们希望每一次测试开始都启动 mock 服务器, 测试结束将服务关掉, Vitest 提供了四个 api 来实现这个过程.<br>\n在 Vitest.config.ts 中, 添加 setupFiles 选项, 该选项接受<code>string|string[]</code>作为文件路径, 写入的文件每次 Vitest 启动都会自动执行.</p>\n<pre><code class=\"language-ts\">defineConfig({\n  test: {\n    // ...\n    setupFiles: './src/setup.ts'\n    // ...\n  }\n})\n</code></pre>\n<p>在 setup.ts 文件中, 我们调用 Vitest 钩子:</p>\n<pre><code class=\"language-ts\">import { server } from './mocks/server'\nimport { beforeAll, afterAll, afterEach } from 'vitest'\n\n// 在每一次测试开始前开启服务器\nbeforeAll(() =&gt; server.listen({ onUnhandledRequest: 'error' }))\n// 在每一次测试结束后关闭服务器\nafterAll(() =&gt; server.close())\n// 在每一个用例结束后重置 handlers\nafterEach(() =&gt; server.resetHandlers())\n</code></pre>\n<p>开启测试, 会显示测试已通过.<br>\n<img src=\"https://r2.ray-d-song.com/202312141529162.png\" alt=\"unit test pass\"><br>\n请注意, 因为 msw 的作用是拦截请求而不是开启模拟服务器, 因此直接本地调用并不起作用.</p>\n<h1>异步测试</h1>\n<h1>优化测试过程</h1>\n<h2>内联测试</h2>\n<p>就和内联样式表一样, 所谓内联测试就是将测试代码和源码写在一起.<br>\n改造一下正则表达式的例子:</p>\n<pre><code class=\"language-ts\">/** /src/reg/phone.ts */\nexport function regChinesePhoneNumber(phoneNumber: string) {\n  const regex = /^1[3456789]\\d{9}$/\n  return regex.test(phoneNumber)\n}\n\n// 内联测试应该放在源码的底部\n/**\n * 为了解决 ts 报错\n * 需要在 tsconfig.json 中添加\n * {&quot;compilerOptions&quot;: {&quot;types&quot;: [&quot;vitest/importMeta&quot;]}}\n */\nif(import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('phone number belongs to Chinese', () =&gt; {\n    expect(regChinesePhoneNumber('41772566381')).toBe(false)\n  })\n}\n</code></pre>\n<p>随后更新一下<code>vitest.config.ts</code>.</p>\n<pre><code class=\"language-ts\">export default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'], \n  }\n})\n</code></pre>\n<p>可以看到新运行的用例增加了一个非<code>test.ts</code>结尾的文件.<br>\n<img src=\"https://r2.ray-d-song.com/202312141609782.png\" alt=\"in source test\"><br>\n这样做的缺点是会造成打包后的代码体积膨胀, 但我们可以做一些处理让代码块作为不会被执行的区块被 tree-shake 掉.</p>\n<pre><code class=\"language-ts\">/** vite.config.ts */\nexport default defineConfig({\n  define: {\n    'import.meta.vitest': 'undefined', \n  }, \n})\n</code></pre>\n<h2>类型测试 (Experimental)</h2>\n<p>ts 的类型在编译后会被擦除, 也就是说无论类型代码写的有多完备, 对真正运行的 js 代码并不会有影响. 但通过类型测试可以促使类型代码更sound, 以此提高 ts 项目的强健性.<br>\n不过总的来说类型测试并不常用, 此处仅介绍一下一般流程.</p>\n<pre><code class=\"language-ts\">/** /src/types/MPick.d.ts */\n// 实现一个自己的 Pick 方法\nexport type MPick&lt;T, K extends keyof T&gt; = {\n  [P in K]: T[P]\n}\n\n/** /src/types/__test__/MPick.test-d.ts */\n\n// vitest 会自动扫描 .test-d.ts 命令的文件\nimport { expectTypeOf, test } from 'vitest'\nimport type { MPick } from '../MPick'\n\ntest('test mock Pick', () =&gt; {\n  interface Foo {\n    a: string\n    b: number\n  }\n  type Bar = MPick&lt;Foo, 'a'&gt;\n  interface Exp {\n    a: string\n  }\n  expectTypeOf&lt;Bar&gt;().toEqualTypeOf&lt;Exp&gt;()\n})\n</code></pre>\n<p>为了启动类型测试, 需要在启动时指定 --typecheck, 添加一个新的 npm 命令 <code>&quot;test:type&quot;: &quot;vitest --typecheck&quot;</code><br>\n运行<code>pnpm run test:type</code>运行测试</p>\n<h2>可视化</h2>\n<p>Vitest 提供了 UI 界面进行交互, 运行<code>pnpm install @vitest/ui</code>安装, <code>pnpm run test:unit --ui</code> 启动<br>\n<img src=\"https://r2.ray-d-song.com/202312141744611.png\" alt=\"ui\"><br>\n里面涵盖了几乎所有的操作, 还可以查看 console、源码和依赖图.<br>\n<img src=\"https://r2.ray-d-song.com/202312141745142.png\" alt=\"Graph\"></p>\n<h2>代码覆盖率</h2>\n<p>Vitest 通过 V8 提供代码覆盖率检查, 运行<code>pnpm install @vitest/coverage-v8</code>安装<br>\n在 vitest.config 中配置覆盖率选项</p>\n<pre><code class=\"language-ts\">defineConfig({\n  test: {\n    coverage: {\n      enabled: true,\n      reporter: ['html']\n    }\n  }\n})\n</code></pre>\n<p>这样就可以在 ui 界面上看到代码覆盖率结果了<br>\n<img src=\"https://r2.ray-d-song.com/202312141752020.png\" alt=\"coverage ui\"></p>\n",
            "url": "https://ray-d-song.com/post/vitest-unit-test",
            "title": "Vue 使用 Vitest 进行单元测试",
            "date_modified": "2023-12-18T00:00:00.000Z",
            "author": {
                "name": "Ray-D-Song",
                "url": "https://ray-d-song.com"
            }
        },
        {
            "content_html": "<h1>创建项目</h1>\n<p>如果是第一次使用 worker 服务, 需要登录一下</p>\n<pre><code class=\"language-bash\">npx wrangler login\n</code></pre>\n<p>通过命令行交互创建一个名为 event-tracking 的项目</p>\n<pre><code class=\"language-bash\">npm create cloudflare@latest event-tracking\n</code></pre>\n<p>项目创建完成后有两个关键的文件, <code>src/index.ts</code> 是 worker 的入口, <code>wrangler.toml</code> 是总的配置文件.<br>\n进入 dev01 目录, 执行命令创建数据库</p>\n<pre><code class=\"language-bash\">npx wrangler d1 create event-tracking-db\n</code></pre>\n<p>执行上面的命令会生成类似如下内容, 粘贴到<code>wrangler.toml</code>中即可配置项目的数据库连接</p>\n<pre><code class=\"language-toml\">[[d1_databases]]\nbinding = &quot;DB&quot;\ndatabase_name = &quot;event-tracking-db&quot;\ndatabase_id = &quot;xxxxxxxxx-xxxxx-xxxx-xxxx-xxxxxxxxxxxxx&quot;\n</code></pre>\n<p>在项目的根目录下创建 sql/schema.sql 文件用于初始化数据库</p>\n<pre><code class=\"language-sql\">DROP TABLE IF EXISTS view_tracking;\n\nCREATE TABLE IF NOT EXISTS view_tracking\n(article_id CHAR(13) PRIMARY KEY, view_count INT);\n\nINSERT INTO view_tracking (article_id, view_count) values ('1692667782462', 1);\n</code></pre>\n<p>执行以下命令在本地创建数据库进行测试</p>\n<pre><code class=\"language-bash\">npx wrangler d1 execute event-tracking-db --local --file=./sql/schema.sql\n</code></pre>\n<p>所谓本地数据库其实是<code>.wrangler/state/d1/miniflare-D1DatabaseObject</code>文件夹下创建了一个 sqlite.<br>\n所以你可以用自己的数据库软件比如 datagrip 验证操作是否成功.</p>\n<h1>worker 操作数据库</h1>\n<p>我的需求是每次用户访问文章, 前端将文章拼接在路径参数中请求后端, 后端为文章的阅读量 + 1 后返回阅读量给前端.<br>\n修改我们的 worker 文件, 先完成获取 articleId 并将其原样返回的步骤.</p>\n<pre><code class=\"language-ts\">export default {\n\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {\n    const articleId = request.url.split('/').pop()\n\n\t\treturn new Response(articleId)\n\t}\n}\n</code></pre>\n<h2>单测</h2>\n<p>接下来我们对这个简单的 worker 运行测试.<br>\n我这里选择使用 Vitest, 它和 TS 的集成度更高且性能更好. 你可以通过我这篇文章来了解它<a href=\"https://ray-d-song.com/post/1701870426245\">在 Vue 项目中使用 Vitest</a></p>\n<pre><code class=\"language-ts\">import { unstable_dev, type UnstableDevWorker } from 'wrangler'\nimport { describe, beforeAll, afterAll, it, expect } from 'vitest'\n\ndescribe('Event Tracking', () =&gt; {\n  let worker: UnstableDevWorker\n\n  beforeAll(async () =&gt; {\n    worker = await unstable_dev('src/index.ts', {\n      experimental: { disableExperimentalWarning: true }\n    })\n  })\n\n  afterAll(async () =&gt; {\n    await worker?.stop()\n  })\n\n  it('should return path param', async () =&gt; {\n    const response = await worker.fetch('https://thorn.com/post/1701870426245')\n    const str = await response.text()\n    expect(str).toBe('1701870426245')\n  })\n\n})\n/**\n *  Test Files  1 passed (1)\n *  Tests  1 passed (1)\n *  Start at  10:59:31\n *  Duration  524ms\n */\n</code></pre>\n<h2>查询</h2>\n<p>在创建数据库时, 我们插入了初试数据, 利用这个数据进行查询测试:</p>\n<pre><code class=\"language-ts\">/** index.ts */\nexport default {\n\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {\n    const articleId = request.url.split('/').pop()\n\n    const result = await env.DB.prepare(\n      'SELECT view_count FROM view_tracking WHERE article_id = ?'\n    )\n      .bind(articleId)\n      .first()\n    \n\t\treturn new Response(String(result===null?0:result['view_count']))\n\t}\n}\n\n/** index.test.ts */\n\n// 将第一个用例标记为 skit, 跳过该测试\nit.skip('should return path param', async () =&gt; {\n  const response = await worker.fetch('https://thorn.com/post/1701870426245')\n  const str = await response.text()\n  expect(str).toBe('1701870426245')\n})\n\nit(&quot;should return '1'&quot;, async () =&gt; {\n  const response = await worker.fetch('https://thorn.com/post/1692667782462')\n  const str = await response.text()\n  expect(str).toBe('1')\n})\n\n/**\n *  ✓ src/index.test.ts (2)\n *  ✓ Event Tracking (2)\n *    ↓ should return path param [skipped]\n *    ✓ should return '1'\n*/\n</code></pre>\n<h2>更新</h2>\n<p>我们继续在此基础上修改, 在查询数据前, 我们需要为该数据的阅读数 + 1.<br>\n该连续操作并不需要强一致, 因此只需要在之前的操作前再加一条更新操作即可. D1 提供了自己的批处理语法.</p>\n<pre><code class=\"language-ts\">/** index.ts */\nexport default {\n\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {\n    const articleId = request.url.split('/').pop()\n\n    const db = env.DB\n    const batchRes = await db.batch([\n      db.prepare('UPDATE view_tracking SET view_count=view_count+1 WHERE article_id = ?').bind(articleId),\n      db.prepare('SELECT view_count FROM view_tracking WHERE article_id = ?').bind(articleId)\n    ])\n\n    const viewCountVal = batchRes[1]===null ? 0 : (batchRes[1].results[0] as ViewCountObj)['view_count']\n\t\treturn new Response(String(viewCountVal))\n\t}\n}\n</code></pre>\n<p>为了测试每次请求阅读数是否真的+1, 本来应该提供一个新的只读接口, 但为了偷懒我们可以打印每次的结果, 自己观察一下即可:</p>\n<pre><code class=\"language-ts\">/** index.test.ts */\nit(&quot;should return new view_count&quot;, async () =&gt; {\n  const response = await worker.fetch('https://thorn.com/post/1692667782462')\n  const str = await response.text()\n  console.log(str)\n  expect(str).toBeTypeOf('string')\n})\n</code></pre>\n<p>到这里该接口的编写基本完成.</p>\n<h2>写入</h2>\n<p>为了每次发布新的文章都自动插入数据, 我们还需要另一个插入数据接口.<br>\n博客每次执行发布的 actions, 就调用该接口将新的 article_id 写入数据库.<br>\n每个 worker 仅能完成一个工作, 需要的接口就需要创建新的 worker. 为了偷懒我们对之前的 worker 进行改造, 根据倒数第二个参数判断操作类型, 最后一个路径参数作为 article_id.</p>\n<pre><code class=\"language-ts\">/** /src/index.ts */\nimport createHandler from './handlers/create'\nimport readHandler from './handlers/read'\n\nexport interface Env {\n  DB: D1Database\n}\n\nexport default {\n  async fetch(request: Request, env: Env): Promise&lt;Response&gt; {\n    try {\n      const url = request.url.split('/')\n      const articleId = url.pop()\n      const handleType = url.pop()\n      if(articleId?.length !== 13) {\n        throw { code: 400, msg: 'err param' }\n      }\n      switch (handleType){\n        case 'read':\n          return readHandler(articleId, env)\n        case 'create':\n          return createHandler(articleId, env)\n        default:\n          throw { code: 400, msg: 'err handle type' }\n      }\n    } catch(e: any) {\n      return new Response(e.msg, {status: e.code})\n    }\n  }\n}\n\n/** /src/handlers/create.ts */\nimport { Env } from '..';\n\nexport default async function createHandler(articleId: string, env: Env) {\n  const db = env.DB\n  const execRes = await db.prepare('INSERT INTO view_tracking (article_id, view_count) values (?, 1)')\n    .bind(articleId)\n    .run()\n  if(execRes.error) {\n    throw { code: 500, msg: 'err exec'}\n  }\n  return new Response(null, {status: 200})\n}\n\n/** /src/handlers/read.ts */\nimport { Env } from '..'\n\ninterface ViewCountObj {\n  view_count: number\n}\n\nexport default async function readHandler(articleId: string, env: Env): Promise&lt;Response&gt; {\n  const db = env.DB\n  const batchRes = await db.batch([\n    db.prepare('UPDATE view_tracking SET view_count=view_count+1 WHERE article_id = ?').bind(articleId),\n    db.prepare('SELECT view_count FROM view_tracking WHERE article_id = ?').bind(articleId)\n  ])\n\n  const viewCountVal = batchRes[1]===null ? 0 : (batchRes[1].results[0] as ViewCountObj)['view_count']\n  return new Response(String(viewCountVal))\n}\n</code></pre>\n<p>对应的单测文件如下:</p>\n<pre><code class=\"language-ts\">/** /src/__test__/index.test.ts */\nimport { unstable_dev, type UnstableDevWorker } from 'wrangler'\nimport { describe, beforeAll, afterAll, it, expect } from 'vitest'\n\ndescribe('Event Tracking', () =&gt; {\n  let worker: UnstableDevWorker\n\n  beforeAll(async () =&gt; {\n    worker = await unstable_dev('src/index.ts', {\n      experimental: { disableExperimentalWarning: true }\n    })\n  })\n\n  afterAll(async () =&gt; {\n    await worker?.stop()\n  })\n\n  // ...\n\n  it('should return 200', async () =&gt; {\n    const response = await worker.fetch('https://thorn.com/create/1701870426247')\n    const code = response.status\n    console.log(await response.text())\n    expect(code).toBe(200)\n  })\n})\n</code></pre>\n<h1>部署</h1>\n<p>首先将数据库创建 sql文件发布</p>\n<pre><code class=\"language-bash\">npx wrangler d1 execute event-tracking-db --file=./sql/schema.sql \n</code></pre>\n<p>验证是否成功</p>\n<pre><code class=\"language-bash\">npx wrangler d1 execute event-tracking-db --command=&quot;SELECT * FROM view_tracking&quot;\n</code></pre>\n<p>不出意外会出现这玩意<br>\n<img src=\"https://r2.ray-d-song.com/202312151552033.png\" alt=\"result image\"><br>\n最后发布你的 worker</p>\n<pre><code class=\"language-bash\">npx wrangler deploy\n</code></pre>\n<p>成功提示<br>\n<img src=\"https://r2.ray-d-song.com/202312151618252.png\" alt=\"success\"></p>\n<blockquote>\n<p>本博客为服务端渲染, 客户端不会直接调用 worker 接口. 如果你的 app 是 spa, 请记得添加一些防刷操作和入参判断拦截.</p>\n</blockquote>\n",
            "url": "https://ray-d-song.com/post/cloudflare-d1",
            "title": "cloudflare worker/D1 初探",
            "date_modified": "2023-11-18T00:00:00.000Z",
            "author": {
                "name": "Ray-D-Song",
                "url": "https://ray-d-song.com"
            }
        },
        {
            "content_html": "<p>tailwind 一直饱受非议, 其中说的最多的大概就是「我为什么不直接写内联样式?」.<br>\n其实 tailwind 不仅是简写了样式名这么简单, 它是一系列便利的封装.</p>\n<h1>动画</h1>\n<p>举个简单的例子, <code>animate-spin</code> 属性用于添加旋转动画, 常用在 loading 中. 如果你用传统的 css/sass 编写, 那你至少需要以下代码.</p>\n<pre><code class=\"language-css\">animation: spin 1s linear infinite;\n\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n</code></pre>\n<h1>交互</h1>\n<p>如果你希望一个 button 在鼠标炫富时颜色变浅, 在 tailwind 中只需要简单的<code>hover:opacity-90</code>, 传统的 css 则需要:</p>\n<pre><code class=\"language-css\">.btn:hover {\n  background-color: rga(xxx,xxx,xxx, 0.9)\n}\n</code></pre>\n<h1>响应式设计</h1>\n<p>同时现代很多网页需要同时满足大屏设备和移动小屏设备的适配, 一般我们会用 css3 的 @media 来根据窗口尺寸编写不同的 css.</p>\n<pre><code class=\"language-css\">@media (max-width: 768px) {\n  body {\n    width: 80%\n  }\n}\n</code></pre>\n<p>在 tailwind 上, 适配 768px 宽度的设备, 你只要在样式前加入 <code>md</code> 前缀即可.</p>\n<pre><code class=\"language-html\">&lt;body class=&quot;md:w-4/5&quot;&gt;\n</code></pre>\n<h1>利好无设计开发</h1>\n<p>个人或者小团队开发产品, 没有专业的设计师出图, 写组件相当痛苦.<br>\n例如 box-shadow 属性, button、card、modal, 每个都需要不一样的 shadow 样式. 在自己编写的时候经常要重复修改多次来达到一个比较好的效果, twc 提供了 7 个不同规格的选项, 都是泛用性非常高的选择.<br>\n现在你要写一个现代化外观的按钮只需要<code>class=&quot;shadow-md rounded-lg&quot;</code>就行了.</p>\n<h1>新的组件模式</h1>\n<p>tailwind 还有个衍生品, Headless UI. 将组件的功能和样式彻底分离. 很多时候组件的功能是相同的 , 但是需要不同的样式, 有时候样子一样的组件却需要完全不同的 api. Headless 就是为了解决这个问题.</p>\n<blockquote>\n<p>NuxtLab UI 就是一个无头tailwind组件库, 闲得蛋疼可以看看, 代码很干净.</p>\n</blockquote>\n<h1>class 也太特么长了</h1>\n<p>这是一个由 tailwind 编写的 checkbox, 做了动效和深色适配.</p>\n<pre><code class=\"language-html\">&lt;input type=&quot;checkbox&quot; class=&quot;w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600&quot;/&gt;\n</code></pre>\n<p>看到这个长度是不是蚌埠住了. 没关系 tailwind 有<code>@layer</code>和<code>@apply</code>, 你可以像组织传统 css 一样去组织 tailwind, 封装自己的样式组件.</p>\n<pre><code class=\"language-css\">@layer components {\n  .checkbox {\n    @apply\n    w-4\n    h-4\n    text-blue-600\n    bg-gray-100\n    border-gray-300\n    rounded\n    focus:ring-blue-500\n    dark:focus:ring-blue-600\n    dark:ring-offset-gray-800\n    focus:ring-2\n    dark:bg-gray-700\n    dark:border-gray-600\n  }\n}\n</code></pre>\n<p>过长的样式导致的问题是无法避免的, 即便你直接写内联也是一样, 最终一定会回到封装样式组件的路上. 但之前所有的好处(抽象、减少代码量、响应式...)都还在.<br>\n这也是一种「不过早抽象」的价值. 一个小的 idea, 你可以一把梭抢先实现原型, 后期再抽离维护, tailwind 降低了这一操作的难度.</p>\n<blockquote>\n<p>当然, 这种种好处的前提是, 要么你写风格多样化的 C 端界面, 要么需要创建属于自己团队的组件库. 然而很明显, 大多数公司还停留在<code>element antd</code>一把梭的阶段. 但这当然不是 tailwind 的问题.</p>\n</blockquote>\n<blockquote>\n<p>实际上海外 <code>3T架构(Next tRPC Tailwind)</code> 已经火了有一阵了, 当然你也可以说这是前端瞎折腾, 但这确实是写出「现代、好看、交互强的界面」的捷径.</p>\n</blockquote>\n",
            "url": "https://ray-d-song.com/post/value-of-tailwind",
            "title": "TailwindCSS 的价值",
            "date_modified": "2023-10-11T00:00:00.000Z",
            "author": {
                "name": "Ray-D-Song",
                "url": "https://ray-d-song.com"
            }
        },
        {
            "content_html": "<p>最近在看 C++ 引入 Fiber 的<a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf\">N4024文档: 区分纤程和协程</a>, 文章给纤程和协程十分明确的区分. 但过去我看过的很多资料会将其混为一谈或者模糊二者的边界, 所以写了这篇博客来总结一下.</p>\n<h1>纤程</h1>\n<p>线程是一种轻量级的线程, 本质是对线程时间进行切片处理, 调度也由用户进行. 最早是 Microsoft 为了解决 Unix 平台的引用程序移植到 Windows 上时出现的问题而发起的提案.<br>\n因此, 纤程是一种偏底层的概念, 通常由操作系统或runtime自动管理, 并不需要程序员手动干预. 例如 Windows 上的纤程就是在其内核上实现.</p>\n<blockquote>\n<p>值得注意的是, php8 引入的 Fiber 虽然叫做纤程, 其本质是协程.</p>\n</blockquote>\n<p>一个线程可以包含多个纤程, 纤程的好处是可以有效防止长时间的线程挂起. 例如在 IO 操作时, 实例化一个纤程进行 IO 操作, 在该纤程阻塞的过程中, 因为仅占用了一部分的时间切片, 程序依旧可以继续执行.</p>\n<h1>协程</h1>\n<p>协程的核心就是协作, 通过明确的挂起和恢复来控制执行的流程，使得不同任务之间可以更好地协同工作，共享信息，避免竞态条件，提高性能.<br>\n协程在许多语言中都有实现, 例如 <code>Lua、Go、Ruby、Java(Virtual Threads)</code>, <code>Python 和 JavaScript(基于生成器)</code>.<br>\n如果要用一句话来总结协程: <code>控制流的主动让出和恢复</code>.</p>\n<h2>有栈协程和无栈协程</h2>\n<p>协程有很多种, 按照多个协程之间是否存在调用栈, 可以分为<code>有栈协程(如goroutine、lua协程)</code>和<code>无栈协程(如JavaScript、Dart、Python)</code>.</p>\n<blockquote>\n<p>调用栈的作用是保存协程挂起时的状态.<br>\n有栈协程在恢复时会将其上下文从栈内存中捞出恢复到系统栈中.<br>\n无栈协程的挂起和恢复则依赖闭包和状态机实现.</p>\n</blockquote>\n<h2>对称协程和非对称协程</h2>\n<p>非对称协程提供<code>两种控制操作</code>, <code>调用协程</code>和<code>挂起协程</code>. 非对称协程可以看做是其调用者的从属, 跟特定调用者绑定, 在让出控制权时, 只能回到原调用者.<br>\n对称协程提供<code>单个控制操作</code>, 可以通过该操作在协程之间显示的传递控制权. 对称协程在启动后和原调用者就没什么关系了, 也因此, 对称协程需要一个调度器去选择转移控制权操作的目标协程.</p>\n<h3>对称</h3>\n<p>对称协程的例子非常少, 以下是 C++ <code>Boost.Coroutine</code> 的示例.</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;coroutine&gt;\n\nstruct CountingCoroutine {\n    struct promise_type {\n        int current_value = 0;\n\n        CountingCoroutine get_return_object() {\n            return CountingCoroutine(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this));\n        }\n\n        std::suspend_always initial_suspend() { return {}; }\n        std::suspend_always final_suspend() noexcept { return {}; }\n        void return_void() {}\n        void unhandled_exception() {}\n        std::suspend_always yield_value(int value) {\n            current_value = value;\n            return {};\n        }\n    };\n\n    std::coroutine_handle&lt;promise_type&gt; coroutine;\n\n    CountingCoroutine(std::coroutine_handle&lt;promise_type&gt; handle) : coroutine(handle) {}\n\n    ~CountingCoroutine() {\n        if (coroutine)\n            coroutine.destroy();\n    }\n\n    int getValue() const {\n        return coroutine.promise().current_value;\n    }\n\n    void resume() {\n        coroutine.resume();\n    }\n};\n\nCountingCoroutine generateNumbers() {\n    for (int i = 0; i &lt; 10; ++i) {\n        //移交控制权\n        co_yield i;\n    }\n}\n\nint main() {\n    CountingCoroutine counter = generateNumbers();\n\n    while (counter.coroutine) {\n        std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; counter.getValue() &lt;&lt; std::endl;\n        //回到 co_yield 继续执行\n        counter.resume();\n    }\n\n    return 0;\n}\n</code></pre>\n<p>在 Go 语言中, 我们可以通过 chan 在没有特定从属关系的情况下完成协程间控制权的转移, 也算是对称协程的实现:</p>\n<pre><code class=\"language-go\">func main() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n\n    var wg sync.WaitGroup\n\n    wg.Add(1)\n    go func() { // &lt;--- 1\n        defer wg.Done()\n        for val := range ch1 {\n            fmt.Println(val)\n        }\n    }()\n\n    wg.Add(1)\n    go func() { // &lt;--- 2\n        defer wg.Done()\n        for val := range ch2 {\n            ch1 &lt;- val\n        }\n        close(ch1)\n    }()\n\n    wg.Add(1)\n    go func() { // &lt;--- 3\n        defer wg.Done()\n        for i := 1; i &lt;= 5; i++ {\n            ch2 &lt;- i\n        }\n        close(ch2)\n    }()\n\n    wg.Wait()\n}\n</code></pre>\n<p>如果按照代码的顺序执行, 那正确的排列顺序是 3 2 1, 但在此处由于channel的阻塞特性, 第一个goroutine会等待第二个goroutine将数据从 ch2 传输到 ch1, 而第二个goroutine会等待第三个goroutine将数据发送到 ch2, 这就保证了它们的执行顺序. 最后，当所有goroutine都完成并且WaitGroup计数为0时, wg.Wait() 返回, 程序退出.</p>\n<h3>非对称</h3>\n<p>JavaScript 的 async、await、promise 则是创建非对称协程的工具.</p>\n<pre><code class=\"language-javascript\">// async 标记的函数会创建协程\nconst useFetch = async () =&gt; { \n  // 执行到 await 处会将该协程挂起, 直到 fetch 返回\n  const res = await fetch('https://www.v2ex.com/api/topics/hot.json')\n  return res.json()\n}\n\nconst main = () =&gt; {\n  console.log('main start')\n  // 执行到此处, 控制权转移到协程\n  useFetch().then(res =&gt; { \n    // 执行到函数内部 await 处, 暂时挂起, 控制权返回到 main\n    console.log(`fetch res: ${res}`)\n  })\n  console.log('main end')\n}\n\nmain()\n/**\n * main start\n * main end\n * fetch res: ...\n */\n</code></pre>\n<p>可以看到, 在 JS 中, 协程转移的控制权一定会返回到协程的调用者上.</p>\n<h1>异同</h1>\n<p>看到这里, 会发现纤程和协程极为相似.<br>\n没错, 大框架上两者的基本概念是一样的. 仅有的区别是纤程的状态保存由操作系统API提供, 而协程保存和恢复的方式由语言或库提供, 背后的实现更是则多种多样.<br>\n所以我们可以认为: 纤程实际上就是由操作系统提供的协程.<br>\n参考<a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf\">Distinguishing coroutines and fibers</a>, 以下是一些细节的差别:</p>\n<ol>\n<li>Fiber 在发起后不再依赖于发起它的程序存在, 可以拥有独立的生命周期.<br>\nCoroutine 作为发起者的「子程序」, 不存在独立的生命周期.</li>\n<li>Fiber 和 Thread 行为模式基本一致. 存在一个调度器, 某个 Fiber 被阻塞, 会将控制权移交至调度器, 由调度器去唤起其他准备运行的 Fiber.<br>\n对称协程的行为方式和 Fiber 基本一致. 非对称协程不存在调度器, 控制权会回到发起者.</li>\n</ol>\n",
            "url": "https://ray-d-song.com/post/coroutine-and-fiber",
            "title": "协程(Coroutine)和纤程(Fiber)",
            "date_modified": "2023-09-12T16:00:00.000Z",
            "author": {
                "name": "Ray-D-Song",
                "url": "https://ray-d-song.com"
            }
        },
        {
            "content_html": "<blockquote>\n<p>本文封面和思路来源于 Ruby China 2021 By 东仙队长的分享: <a href=\"https://www.bilibili.com/video/BV1h3411v7kq/?spm_id_from=333.999.0.0&amp;vd_source=371668a779fa4a755fcbf62901a22d71\">Ruby 高并发编程指北</a></p>\n</blockquote>\n<h1>并发</h1>\n<p>假设有一个处理器, 因为只有一个核心, 所以同时他只能运行一个进程, 又因为一个进程上同一时间只能运行一个线程(task). 所以你可以认为, 同一时间, 这颗处理器只能处理一个任务.</p>\n<p>操作系统会将<code>cpu 使用时间</code>这一资源进行切分, 这就是<code>时间分片</code>. 划分好的资源会按照调度算法分配给各个线程去使用. 进程内线程切换大概就是下面这种感觉:<br>\n<img src=\"https://r2.ray-d-song.com/202309091531790.png\" alt=\"线程调度\"></p>\n<p>因为现代计算机性能足够强劲, 所以使用者体感上是 task_1、2、3 在同时运行, 这就是并发.</p>\n<p>我并不想用<code>「多个任务同时发生」</code>这种模糊的表达, 在我看来<code>「并发」</code>之所以被称为<code>「并发」</code>单纯是翻译后中文表达的问题.<br>\n<code>无论如何, 同时确实只有一个任务在进行</code></p>\n<h1>并行</h1>\n<p>并行就要好理解的多, 你有一个多核心处理器, 例如拥有两个核心的老古董E6600. 因为有两个核心, 同时能运行两个进程, 每个进程可以运行一个线程. 因此, 你的电脑就能真正的在同一时间运行两个任务.<br>\n大概就是下面这种感觉:<br>\n<img src=\"https://r2.ray-d-song.com/202309091547730.png\" alt=\"并行\"></p>\n<h1>程序设计</h1>\n<p>之前刷知乎时, 看到这样一种说法:<code>「你的程序首先必须支持并发, 才能支持并行」</code><br>\n因为并发不仅是对程序执行状态的一种描述, 也是一种程序设计的方法论:<br>\n设计并发程序的条件就是<code>「程序的执行不依赖先后顺序、不依赖精确时序」</code>.<br>\n而一段不依赖先后顺序、不依赖精确时序的程序, 自然可以拆分成多段, 在多个线程上运行. 这多个线程又可以运行在不同的进程之上, 进而实现<code>并行</code>.</p>\n<p>首先我们来看看最常见的 web 应用场景, 从接收到用户请求到返回, 需要这些步骤:<br>\n<img src=\"https://r2.ray-d-song.com/202309092334861.png\" alt=\"web app\"><br>\n其中<code>DB operation</code>占据了最大的空间, 因为数据库操作确实是最耗时的操作.</p>\n<h1>多线程并发</h1>\n<p>我们来假设一种极端的情况, 如果一直只有一个线程在运行, 那么运行过程就会变成这样:<br>\n<img src=\"https://r2.ray-d-song.com/202309092339287.png\" alt=\"单线程\"><br>\n如果是这样的话, 我想我们这台单核的机器没几个用户就 burn out 了.<br>\n应对这种情况, 最简单的思路就是多开几个线程, 虽然我们只有一个进程, 但当第一个线程卡在数据库操作时, 可以将控制权转移到其他线程进行操作.<br>\n<img src=\"https://r2.ray-d-song.com/202309092351360.png\" alt=\"多线程\"></p>\n<h1>协程</h1>\n<p>多线程并发, 一切看起来都很美好, 但有两个问题, 一个是计算机能启动的线程数量是有限的, 还有就是线程的切换有着客观的成本.<br>\n那么如果我们可以自己在程序中<code>模拟线程</code>, 切换的不再是线程, 而是执行的程序方法. 岂不是可以用极低的成本去并发?<br>\n这个模拟线程, 或者说<code>轻量线程/用户线程</code>, 就是协程.<br>\n有了协程, 我们可以更细粒度的控制程序的执行. 以下是 node.js 协程(async异步)的例子:</p>\n<pre><code class=\"language-js\">async function App(request, response) {\n  const id = request.query.id // &lt;- read req and parsing\n  try {\n    const result = await DB.find({ id }) // &lt;- DB operation\n    res.json({ // generate json and response\n      code: 200,\n      data: result\n    })\n  } catch(e) {\n    // ...\n  }\n}\n</code></pre>\n<p>当程序执行到<code>await</code>标识的数据库操作时, 就会在当前方法内形成阻塞, 等待数据库的返回结果. 但对于调用 App() 的方法来说, 程序则会继续向下执行(处理其他的请求).</p>\n<p>整个过程的简略图大概如下:<br>\n<img src=\"https://r2.ray-d-song.com/202309101809693.png\" alt=\"async\"></p>\n<p>关于协程更具体的介绍, 可以看我的这篇文章<a href=\"https://ray-d-song.com/post/1692667782462\">协程(Coroutine)和纤程(Fiber)</a></p>\n<p>实际上这种<code>单线程+协程</code>并发模型, 就是 Node.js 的并发模型.<br>\n这几年协程的火爆, jdk21、php8 都支持了协程方案. 足以提现这种模式的优势.</p>\n<blockquote>\n<p>说到这里, 有没有什么比单线程异步并发更强的方案呢?<br>\n那就是<code>多线程+协程</code>, Go 就是这样的方案. Go 实现了一种更复杂的 Goroutine 到实际线程资源的映射, 使其可以以极低的配置达到恐怖的并发性能</p>\n</blockquote>\n",
            "url": "https://ray-d-song.com/post/single-thread-concurrency",
            "title": "单线程并发",
            "date_modified": "2023-08-16T16:00:00.000Z",
            "author": {
                "name": "Ray-D-Song",
                "url": "https://ray-d-song.com"
            }
        }
    ]
}