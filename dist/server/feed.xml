<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Ray-D-Song</title>
        <link>https://ray-d-song.com/</link>
        <description>Ray's blog, Just for fun</description>
        <lastBuildDate>Thu, 25 Jan 2024 17:55:55 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>Ray-D-Song</title>
            <url>https://ray-d-song.com/avatar.jpeg</url>
            <link>https://ray-d-song.com/</link>
        </image>
        <copyright>CC BY-NC-SA 4.0 2024 © Ray-D-Song</copyright>
        <atom:link href="https://ray-d-song.com/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Vue 使用 Vitest 进行单元测试]]></title>
            <link>https://ray-d-song.comsrc/page/post/vitest-unit-test.md</link>
            <guid>https://ray-d-song.comsrc/page/post/vitest-unit-test.md</guid>
            <pubDate>Mon, 18 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>单元测试的定义</h1>
<blockquote>
<p>本文源码: <a href="https://github.com/Ray-D-Song/vitest-tutorial-sourcecode">https://github.com/Ray-D-Song/vitest-tutorial-sourcecode</a></p>
</blockquote>
<blockquote>
<p>单元测试（英语：Unit Testing）又称为模块测试 [来源请求] ，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。     ———wiki</p>
</blockquote>
<p>在一个典型的 Vue 项目中, 我们经常需要进行单元测试的模块包括以下几种:</p>
<ul>
<li>hooks</li>
<li>工具函数 (utils)</li>
<li>校验规则 (reg)</li>
<li>脚手架 (bin/scaffold)</li>
<li>自定义 vue 指令</li>
<li>全局状态 (store)</li>
</ul>
<h1>初始化 Vitest</h1>
<p>安装 Vitest</p>
<pre><code class="language-bash">pnpm add -D vitest
</code></pre>
<p>Vitest 默认和 Vite 配置集成, 不需要额外的配置文件.<br>
修改<code>package.json</code>, 在<code>script</code>下新增<code>test:unit</code>命令</p>
<pre><code class="language-json">  &quot;scripts&quot;: {
    ...
    &quot;test:unit&quot;: &quot;vitest&quot;,
  },
</code></pre>
<h1>编写测试用例</h1>
<p>测试一个手机号校验函数</p>
<pre><code class="language-ts">/** /reg/phone.ts */
// 校验是否国内手机号
export function regChinesePhoneNumber(phoneNumber: string) {
  const regex = /^1[3456789]\d{9}$/
  return regex.test(phoneNumber)
}

/** /reg/phone.test.ts */
import { describe, expect, test } from 'vitest'
import { regChinesePhoneNumber } from '../phone'

describe('phone', () =&gt; {
  test('phone number belongs to Chinese', () =&gt; {
    expect(regChinesePhoneNumber('17725663831')).toBe(true)
  })
})
</code></pre>
<p>输入命令<code>npm run test:unit</code>, 不出意外你会看到以下内容, 表明测试通过:<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312071947299.png" alt="test result"></p>
<p>编写测试的代码文件通常放置在<code>__test__</code>文件夹中, 命名为<code>xxx.test.ts</code>或<code>xxx.spec.ts</code>, Vitest 会自动运行所有此类命名的文件.<br>
编写测试的基础是<code>describe、test、expect</code>关键字.<br>
<code>describe</code> 用于定义一个测试<code>套件</code>, 套件类似于 js 的模块, 用于将多个 test 封装到一起, 搭配<code>skip、only</code>等 api 可以实现选择性测试等功能.<br>
<code>test</code> 用于声明一个测试, 接收测试名称和保存测试期望的函数.<br>
<code>expect</code> 用于设置断言, Vitest 默认提供基于<code>chai</code>的断言, 你不知道什么是 chai 没关系, 断言是单元测试的关键助手, 后面会详细介绍</p>
<h1>实践</h1>
<p>接下来, 我们对几种常见的场景进行单测</p>
<h2>hooks</h2>
<p>hooks 是逻辑的封装, 是最需要单测的场景.<br>
编辑器和表单有一个常见需求是记录上一次更改时间, 我们可以通过几行代码封装一个 hooks.</p>
<pre><code class="language-ts">/** /src/hooks/useLastChange.ts */
import { watch, ref, type WatchSource } from 'vue'
import moment from 'moment/moment'

export function useLastChange(source: WatchSource) {
  const lastChange = ref('')

  watch(source, () =&gt; {
    lastChange.value = moment().format('YYYY-MM-DD HH:mm:ss')
  })

  return lastChange
}

/** /src/hooks/__test__/useLastChange.test.ts */
import { expect, it } from 'vitest'
import { nextTick, ref } from 'vue'
import { useLastChange } from '../useLastChange'

it('update lastChange when source changes', async () =&gt; {
  const source = ref('')
  const lastChange = useLastChange(source)
  const snapShot01 = lastChange.value
  source.value = 'Ray'
  await nextTick()
  const snapShot02 = lastChange.value

  expect(snapShot01).not.toBe(snapShot02)
})
</code></pre>
<p>hooks 的测试比较简单, 就是执行后比对结果. utils 和 reg 也是类似, 此处略过.</p>
<h2>scaffold</h2>
<p>脚手架一般是框架自身提供的命令行工具, 用于生成模板代码, 放置于 bin 目录.<br>
Vue 和 React 自身只提供了创建项目工具, 没有提供类似 Rails Command Line 的项目搭建工具. 因此前端spa项目的脚手架都是自己针对常见业务场景的封装.<br>
脚手架一般通过 npm 命令执行, 在 package.json 中添加一条命令</p>
<pre><code class="language-json">&quot;create&quot;: &quot;node ./bin/create.js --type=$npm_config_type --path=$npm_config_path
</code></pre>
<p>运行<code>npm run create --type=table --path='/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/views/TestTable.vue' </code>, 就会执行 /bin/index 脚本中的内容并将 type 和 path 值作为参数传递.<br>
编写 create 脚本:</p>
<pre><code class="language-js">/** /src/bin/create.js */
import minimist from 'minimist'
import { readFileSync, writeFileSync } from 'fs'

function main() {
  // 使用 minimist 处理参数
  const args = minimist(process.argv.slice(2))
  const { type, path } = args
  let temp = ''
  if(type === 'table') {
    temp = readFileSync('./src/bin/dist/table', 'utf-8') 
  }
  writeFileSync(path, temp)
  console.log('\n创建完成')
}

main()
</code></pre>
<p>脚手架其实只进行 3 个操作, 获取参数, 读取对应的模板, 创建目标文件.<br>
vitest 和 jest 并没有比较好的执行 npm 命令的方法, 因此我们要对上面的方法稍加改造:</p>
<pre><code class="language-js">/** /src/bin/create.js */
import { readFileSync, writeFileSync } from 'fs'

function create(args) {
  const { type, path } = args
  let temp = ''
  if(type === 'table') {
    temp = readFileSync('./src/bin/dist/table', 'utf-8') 
  } else {
    throw '当前仅支持生成 table 类型'
  }
  writeFileSync(path, temp)
  console.log('\n创建完成')
}

export default create

/** /src/bin/index.js */
import create from './create'

// 使用 minimist 处理参数
const args = minimist(process.argv.slice(2))
try {
  create(args)
} catch(e) {
  console.log(e)
}
</code></pre>
<p>将脚本入口和执行方法分离是为了防止 unit test 过程中自动执行 main 方法报错.<br>
接下来我们就可以在 test 中导入 create 方法进行测试. 断言可以通过读取生成的模板内容和 table 文件中内容进行比较.<br>
以下是测试用例, 从参数、生成内容进行测试</p>
<pre><code class="language-ts">/** /src/bin/__test__/create.test.ts */
import create from '../create'
import { describe, expect, it } from 'vitest'
import { readFileSync } from 'fs'

describe('bin scaffold module', () =&gt; {

  describe('create table error args', () =&gt; {
    it('error temp type', () =&gt; {
      try {
        create({
          type: 'dialog',
          path: '/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/dialog.vue'
        })
      } catch(e) {
        expect(e).toBe('当前仅支持生成 table 类型')
        const product = readFileSync('/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/dialog.vue', 'utf-8')
        expect(product).toBeUndefined
      }
    })
  })

  it('create table', () =&gt; {
    create({
      type: 'table',
      path: '/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/table.vue'
    })
    const temp = readFileSync('/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/dist/table', 'utf-8')
    const product = readFileSync('/Users/ray-d-song/temp/SourceCode/vitest-tutorial-sourcecode/src/bin/__test__/table.vue', 'utf-8')
    expect(temp).toBe(product)
  })

})
</code></pre>
<p><img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312121120257.png" alt="result"></p>
<h2>自定义 Vue 指令</h2>
<p>自定义一个 v-debounce, 用于给按钮增加防抖效果</p>
<pre><code class="language-ts">import _ from 'lodash'

const vDebounce = {
  beforeMount(el: HTMLElement, binding: {value: () =&gt; void}) {
    el.addEventListener('click', _.debounce(binding.value, 600))
  }
}

app.directive('debounce', vDebounce)
</code></pre>
<p>为了测试这个指令, 我们需要模拟<code>组件挂载-&gt;用户点击-&gt;方法调用的过程</code>, 也就是我们需要调用部分组件测试的能力. <code>@vue/test-utils</code> 是常用的 Vue 组件测试库.</p>
<pre><code class="language-bash">pnpm install @vue/test-utils
</code></pre>
<p>vue-test-utils 兼容 jest 和 Vitest, 安装后可以直接使用. 下面是自定义指令的功能测试:</p>
<pre><code class="language-ts">/** /src/utils/__test__/directives.test.ts */
import { describe, expect, it } from 'vitest'
import { defineComponent, nextTick, ref } from 'vue'
import { mount } from '@vue/test-utils'
import { vDebounce } from '../directives'

// 使用 defineComponent 定义测试组件
// 该 api 除了 template 作为字符串传递外
// 还可以使用 tsx 获得更好的代码提示
const tc = defineComponent({
  setup() {
    const num = ref(0)
    function add() {
      num.value++
    }
    return {
      num,
      add  
    }
  },
  template: '&lt;button v-debounce=&quot;add&quot;&gt;num: {{num}}&lt;/button&gt;'
})

describe('custom directives', async () =&gt; {
  // vue-test-utils 的 mount api, 将组件实例化
  it('debounce submit', async () =&gt; {
    const wrapper = mount(tc, {
      global: {
        directives: {
          debounce: vDebounce
        }
      }
    })

    // 每过 200 毫秒点击一次 button
    const interval = setInterval(async () =&gt; {
      // find api 查找目标元素
      await wrapper.find('button').trigger('click')
    }, 200)
    // 阻塞 1000 秒, 让点击事件在 1 秒内执行 4 次
    await new Promise(resolve =&gt; setTimeout(resolve, 1000))

    clearInterval(interval)

    // 阻塞 700 秒, 等待函数执行
    await new Promise(resolve =&gt; setTimeout(resolve, 700))
    // 确保组件重新渲染
    await nextTick()
    // 获取目标元素
    const btn = wrapper.get('button')
    // 对目标元素的文本进行断言
    expect(btn.text()).toBe('num: 1')
  })
})
</code></pre>
<h2>store</h2>
<p>大型的前端项目基本都会用到全局的状态管理库, Vue3 最流行的是 Pinia.<br>
Pinia 提供了可用于测试的 api.</p>
<pre><code class="language-ts">import { createPinia, setActivePinia } from 'pinia'
import { beforeEach, describe, expect, it } from 'vitest'
import { useCounterStore } from '../counter'

describe('Counter Store', () =&gt; {
  beforeEach(() =&gt; {
    setActivePinia(createPinia())
  })

  it('increments', () =&gt; {
    const counter = useCounterStore()
    expect(counter.count).toBe(0)
    counter.increment()
    expect(counter.count).toBe(1)
  })
})
</code></pre>
<p>这里引入了一个新的 api: <code>beforeEach</code>, 这是一种<code>测试生命周期钩子</code>, 传入的方法在每个测试用例之前执行.<br>
我们传入了 pinia 的 <code>setActivePinia</code> api, 这是个 SSR 经常使用的 api, 用户设置一个激活的 Pinia 实例.</p>
<h1>断言</h1>
<p>断言是单元测试的核心, 本质一堆用来判断结果的函数库.<br>
在上面的例子, 我们使用了<code>toBe</code>断言, 这是最常用的断言, 该断言用于判断值相等或者相同引用, 类似于<code>Object.is</code>.<br>
以下为常用的几种断言:</p>
<table>
<thead>
<tr>
<th>断言</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>not</td>
<td>取反</td>
</tr>
<tr>
<td>toBe</td>
<td>判断值或对象引用是否相同</td>
</tr>
<tr>
<td>toEqual</td>
<td>判断对象值是否相同</td>
</tr>
<tr>
<td>toBeGreaterThan</td>
<td>大于</td>
</tr>
<tr>
<td>toBeGreaterThanOrEqual</td>
<td>大于等于</td>
</tr>
<tr>
<td>toBeLessThan</td>
<td>小于</td>
</tr>
<tr>
<td>toBeLessThanOrEqual</td>
<td>小于等于</td>
</tr>
<tr>
<td>soft</td>
<td><code>expect.soft</code> 遇到某条用例失败也不会停止测试, 直到所有用例执行完毕展示所有错误</td>
</tr>
<tr>
<td>toBeTypeOf</td>
<td>断言类型是否相同</td>
</tr>
<tr>
<td>toBeInstanceOf</td>
<td>判断是否是目标类的实例</td>
</tr>
<tr>
<td>toStrictEqual</td>
<td>严格相等, 会检查具有 undefined 属性的 key、数组稀疏性、对象类型是否相等</td>
</tr>
<tr>
<td>toContain</td>
<td>检查数组元素和子串</td>
</tr>
<tr>
<td>toThrowError</td>
<td>检查函数调用过程中是否报错</td>
</tr>
<tr>
<td>resolves</td>
<td><code>expect(func()).resolves.toEqual</code></td>
</tr>
<tr>
<td>rejects</td>
<td><code>expect(func()).rejects.toThrow</code></td>
</tr>
</tbody>
</table>
<h1>mock</h1>
<p>为了应对业务耦合, 做到仅测试功能代码, 我们可以使用 mock 工具进行数据模拟.<br>
最常见的场景是模拟请求, 一般情况下你可以自己用一个 Promise 来模拟请求结果, 但有些情况也许你需要更真实的场景.<br>
常用的 mock 工具, 例如 APIfox, 是通过接口定义来「启动一个真实的服务器返回假数据」. 而 Vitest 并不会启动真正的 node 服务器, 而是通过<code>mswjs</code>来拦截对应地址的请求.<br>
也就是说你可以很方便的去模拟「异常请求」的场景.<br>
首先安装 msw: <code>pnpm install msw</code></p>
<p>假设我们需要请求<code>https://thorn.mock/test</code>这个接口, 获取<code>{msg: 'hey'}</code>的 json 数据, 以下是我们的测试用例.</p>
<pre><code class="language-ts">/** /src/api/__test__/mock.test.ts */
import { describe, expect, it } from 'vitest'

describe('mock', async () =&gt; {
  it('mock api', async () =&gt; {
    const response = await fetch('https://thorn.mock/test') 
    // 使用 toEqual 来比较对象值
    expect(await response.json()).toEqual({
      msg: 'hey'
    })
  })
})
</code></pre>
<p>为了 mock 这个接口, 我们需要按照 msw 的语法编写一个 server.</p>
<pre><code class="language-ts">/** /src/mocks/server.ts */
import { setupServer } from 'msw/node'
import { HttpHandler, HttpResponse, http } from 'msw'

export const handlers: Array&lt;HttpHandler&gt; = [
  http.get('https://thorn.mock/test', () =&gt; {
    return HttpResponse.json({
      msg: 'hey'
    })
  })
]

export const server = setupServer(...handlers)
</code></pre>
<p>理想状况下, 我们希望每一次测试开始都启动 mock 服务器, 测试结束将服务关掉, Vitest 提供了四个 api 来实现这个过程.<br>
在 Vitest.config.ts 中, 添加 setupFiles 选项, 该选项接受<code>string|string[]</code>作为文件路径, 写入的文件每次 Vitest 启动都会自动执行.</p>
<pre><code class="language-ts">defineConfig({
  test: {
    // ...
    setupFiles: './src/setup.ts'
    // ...
  }
})
</code></pre>
<p>在 setup.ts 文件中, 我们调用 Vitest 钩子:</p>
<pre><code class="language-ts">import { server } from './mocks/server'
import { beforeAll, afterAll, afterEach } from 'vitest'

// 在每一次测试开始前开启服务器
beforeAll(() =&gt; server.listen({ onUnhandledRequest: 'error' }))
// 在每一次测试结束后关闭服务器
afterAll(() =&gt; server.close())
// 在每一个用例结束后重置 handlers
afterEach(() =&gt; server.resetHandlers())
</code></pre>
<p>开启测试, 会显示测试已通过.<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312141529162.png" alt="unit test pass"><br>
请注意, 因为 msw 的作用是拦截请求而不是开启模拟服务器, 因此直接本地调用并不起作用.</p>
<h1>异步测试</h1>
<h1>优化测试过程</h1>
<h2>内联测试</h2>
<p>就和内联样式表一样, 所谓内联测试就是将测试代码和源码写在一起.<br>
改造一下正则表达式的例子:</p>
<pre><code class="language-ts">/** /src/reg/phone.ts */
export function regChinesePhoneNumber(phoneNumber: string) {
  const regex = /^1[3456789]\d{9}$/
  return regex.test(phoneNumber)
}

// 内联测试应该放在源码的底部
/**
 * 为了解决 ts 报错
 * 需要在 tsconfig.json 中添加
 * {&quot;compilerOptions&quot;: {&quot;types&quot;: [&quot;vitest/importMeta&quot;]}}
 */
if(import.meta.vitest) {
  const { it, expect } = import.meta.vitest
  it('phone number belongs to Chinese', () =&gt; {
    expect(regChinesePhoneNumber('41772566381')).toBe(false)
  })
}
</code></pre>
<p>随后更新一下<code>vitest.config.ts</code>.</p>
<pre><code class="language-ts">export default defineConfig({
  test: {
    includeSource: ['src/**/*.{js,ts}'], 
  }
})
</code></pre>
<p>可以看到新运行的用例增加了一个非<code>test.ts</code>结尾的文件.<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312141609782.png" alt="in source test"><br>
这样做的缺点是会造成打包后的代码体积膨胀, 但我们可以做一些处理让代码块作为不会被执行的区块被 tree-shake 掉.</p>
<pre><code class="language-ts">/** vite.config.ts */
export default defineConfig({
  define: {
    'import.meta.vitest': 'undefined', 
  }, 
})
</code></pre>
<h2>类型测试 (Experimental)</h2>
<p>ts 的类型在编译后会被擦除, 也就是说无论类型代码写的有多完备, 对真正运行的 js 代码并不会有影响. 但通过类型测试可以促使类型代码更sound, 以此提高 ts 项目的强健性.<br>
不过总的来说类型测试并不常用, 此处仅介绍一下一般流程.</p>
<pre><code class="language-ts">/** /src/types/MPick.d.ts */
// 实现一个自己的 Pick 方法
export type MPick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P]
}

/** /src/types/__test__/MPick.test-d.ts */

// vitest 会自动扫描 .test-d.ts 命令的文件
import { expectTypeOf, test } from 'vitest'
import type { MPick } from '../MPick'

test('test mock Pick', () =&gt; {
  interface Foo {
    a: string
    b: number
  }
  type Bar = MPick&lt;Foo, 'a'&gt;
  interface Exp {
    a: string
  }
  expectTypeOf&lt;Bar&gt;().toEqualTypeOf&lt;Exp&gt;()
})
</code></pre>
<p>为了启动类型测试, 需要在启动时指定 --typecheck, 添加一个新的 npm 命令 <code>&quot;test:type&quot;: &quot;vitest --typecheck&quot;</code><br>
运行<code>pnpm run test:type</code>运行测试</p>
<h2>可视化</h2>
<p>Vitest 提供了 UI 界面进行交互, 运行<code>pnpm install @vitest/ui</code>安装, <code>pnpm run test:unit --ui</code> 启动<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312141744611.png" alt="ui"><br>
里面涵盖了几乎所有的操作, 还可以查看 console、源码和依赖图.<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312141745142.png" alt="Graph"></p>
<h2>代码覆盖率</h2>
<p>Vitest 通过 V8 提供代码覆盖率检查, 运行<code>pnpm install @vitest/coverage-v8</code>安装<br>
在 vitest.config 中配置覆盖率选项</p>
<pre><code class="language-ts">defineConfig({
  test: {
    coverage: {
      enabled: true,
      reporter: ['html']
    }
  }
})
</code></pre>
<p>这样就可以在 ui 界面上看到代码覆盖率结果了<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312141752020.png" alt="coverage ui"></p>
]]></content:encoded>
            <author>songraysmail@gmail.com (Ray-D-Song)</author>
        </item>
        <item>
            <title><![CDATA[cloudflare worker/D1 初探]]></title>
            <link>https://ray-d-song.comsrc/page/post/cloudflare-d1.md</link>
            <guid>https://ray-d-song.comsrc/page/post/cloudflare-d1.md</guid>
            <pubDate>Sat, 18 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<h1>创建项目</h1>
<p>如果是第一次使用 worker 服务, 需要登录一下</p>
<pre><code class="language-bash">npx wrangler login
</code></pre>
<p>通过命令行交互创建一个名为 event-tracking 的项目</p>
<pre><code class="language-bash">npm create cloudflare@latest event-tracking
</code></pre>
<p>项目创建完成后有两个关键的文件, <code>src/index.ts</code> 是 worker 的入口, <code>wrangler.toml</code> 是总的配置文件.<br>
进入 dev01 目录, 执行命令创建数据库</p>
<pre><code class="language-bash">npx wrangler d1 create event-tracking-db
</code></pre>
<p>执行上面的命令会生成类似如下内容, 粘贴到<code>wrangler.toml</code>中即可配置项目的数据库连接</p>
<pre><code class="language-toml">[[d1_databases]]
binding = &quot;DB&quot;
database_name = &quot;event-tracking-db&quot;
database_id = &quot;xxxxxxxxx-xxxxx-xxxx-xxxx-xxxxxxxxxxxxx&quot;
</code></pre>
<p>在项目的根目录下创建 sql/schema.sql 文件用于初始化数据库</p>
<pre><code class="language-sql">DROP TABLE IF EXISTS view_tracking;

CREATE TABLE IF NOT EXISTS view_tracking
(article_id CHAR(13) PRIMARY KEY, view_count INT);

INSERT INTO view_tracking (article_id, view_count) values ('1692667782462', 1);
</code></pre>
<p>执行以下命令在本地创建数据库进行测试</p>
<pre><code class="language-bash">npx wrangler d1 execute event-tracking-db --local --file=./sql/schema.sql
</code></pre>
<p>所谓本地数据库其实是<code>.wrangler/state/d1/miniflare-D1DatabaseObject</code>文件夹下创建了一个 sqlite.<br>
所以你可以用自己的数据库软件比如 datagrip 验证操作是否成功.</p>
<h1>worker 操作数据库</h1>
<p>我的需求是每次用户访问文章, 前端将文章拼接在路径参数中请求后端, 后端为文章的阅读量 + 1 后返回阅读量给前端.<br>
修改我们的 worker 文件, 先完成获取 articleId 并将其原样返回的步骤.</p>
<pre><code class="language-ts">export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {
    const articleId = request.url.split('/').pop()

		return new Response(articleId)
	}
}
</code></pre>
<h2>单测</h2>
<p>接下来我们对这个简单的 worker 运行测试.<br>
我这里选择使用 Vitest, 它和 TS 的集成度更高且性能更好. 你可以通过我这篇文章来了解它<a href="https://ray-d-song.com/post/1701870426245">在 Vue 项目中使用 Vitest</a></p>
<pre><code class="language-ts">import { unstable_dev, type UnstableDevWorker } from 'wrangler'
import { describe, beforeAll, afterAll, it, expect } from 'vitest'

describe('Event Tracking', () =&gt; {
  let worker: UnstableDevWorker

  beforeAll(async () =&gt; {
    worker = await unstable_dev('src/index.ts', {
      experimental: { disableExperimentalWarning: true }
    })
  })

  afterAll(async () =&gt; {
    await worker?.stop()
  })

  it('should return path param', async () =&gt; {
    const response = await worker.fetch('https://thorn.com/post/1701870426245')
    const str = await response.text()
    expect(str).toBe('1701870426245')
  })

})
/**
 *  Test Files  1 passed (1)
 *  Tests  1 passed (1)
 *  Start at  10:59:31
 *  Duration  524ms
 */
</code></pre>
<h2>查询</h2>
<p>在创建数据库时, 我们插入了初试数据, 利用这个数据进行查询测试:</p>
<pre><code class="language-ts">/** index.ts */
export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {
    const articleId = request.url.split('/').pop()

    const result = await env.DB.prepare(
      'SELECT view_count FROM view_tracking WHERE article_id = ?'
    )
      .bind(articleId)
      .first()
    
		return new Response(String(result===null?0:result['view_count']))
	}
}

/** index.test.ts */

// 将第一个用例标记为 skit, 跳过该测试
it.skip('should return path param', async () =&gt; {
  const response = await worker.fetch('https://thorn.com/post/1701870426245')
  const str = await response.text()
  expect(str).toBe('1701870426245')
})

it(&quot;should return '1'&quot;, async () =&gt; {
  const response = await worker.fetch('https://thorn.com/post/1692667782462')
  const str = await response.text()
  expect(str).toBe('1')
})

/**
 *  ✓ src/index.test.ts (2)
 *  ✓ Event Tracking (2)
 *    ↓ should return path param [skipped]
 *    ✓ should return '1'
*/
</code></pre>
<h2>更新</h2>
<p>我们继续在此基础上修改, 在查询数据前, 我们需要为该数据的阅读数 + 1.<br>
该连续操作并不需要强一致, 因此只需要在之前的操作前再加一条更新操作即可. D1 提供了自己的批处理语法.</p>
<pre><code class="language-ts">/** index.ts */
export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {
    const articleId = request.url.split('/').pop()

    const db = env.DB
    const batchRes = await db.batch([
      db.prepare('UPDATE view_tracking SET view_count=view_count+1 WHERE article_id = ?').bind(articleId),
      db.prepare('SELECT view_count FROM view_tracking WHERE article_id = ?').bind(articleId)
    ])

    const viewCountVal = batchRes[1]===null ? 0 : (batchRes[1].results[0] as ViewCountObj)['view_count']
		return new Response(String(viewCountVal))
	}
}
</code></pre>
<p>为了测试每次请求阅读数是否真的+1, 本来应该提供一个新的只读接口, 但为了偷懒我们可以打印每次的结果, 自己观察一下即可:</p>
<pre><code class="language-ts">/** index.test.ts */
it(&quot;should return new view_count&quot;, async () =&gt; {
  const response = await worker.fetch('https://thorn.com/post/1692667782462')
  const str = await response.text()
  console.log(str)
  expect(str).toBeTypeOf('string')
})
</code></pre>
<p>到这里该接口的编写基本完成.</p>
<h2>写入</h2>
<p>为了每次发布新的文章都自动插入数据, 我们还需要另一个插入数据接口.<br>
博客每次执行发布的 actions, 就调用该接口将新的 article_id 写入数据库.<br>
每个 worker 仅能完成一个工作, 需要的接口就需要创建新的 worker. 为了偷懒我们对之前的 worker 进行改造, 根据倒数第二个参数判断操作类型, 最后一个路径参数作为 article_id.</p>
<pre><code class="language-ts">/** /src/index.ts */
import createHandler from './handlers/create'
import readHandler from './handlers/read'

export interface Env {
  DB: D1Database
}

export default {
  async fetch(request: Request, env: Env): Promise&lt;Response&gt; {
    try {
      const url = request.url.split('/')
      const articleId = url.pop()
      const handleType = url.pop()
      if(articleId?.length !== 13) {
        throw { code: 400, msg: 'err param' }
      }
      switch (handleType){
        case 'read':
          return readHandler(articleId, env)
        case 'create':
          return createHandler(articleId, env)
        default:
          throw { code: 400, msg: 'err handle type' }
      }
    } catch(e: any) {
      return new Response(e.msg, {status: e.code})
    }
  }
}

/** /src/handlers/create.ts */
import { Env } from '..';

export default async function createHandler(articleId: string, env: Env) {
  const db = env.DB
  const execRes = await db.prepare('INSERT INTO view_tracking (article_id, view_count) values (?, 1)')
    .bind(articleId)
    .run()
  if(execRes.error) {
    throw { code: 500, msg: 'err exec'}
  }
  return new Response(null, {status: 200})
}

/** /src/handlers/read.ts */
import { Env } from '..'

interface ViewCountObj {
  view_count: number
}

export default async function readHandler(articleId: string, env: Env): Promise&lt;Response&gt; {
  const db = env.DB
  const batchRes = await db.batch([
    db.prepare('UPDATE view_tracking SET view_count=view_count+1 WHERE article_id = ?').bind(articleId),
    db.prepare('SELECT view_count FROM view_tracking WHERE article_id = ?').bind(articleId)
  ])

  const viewCountVal = batchRes[1]===null ? 0 : (batchRes[1].results[0] as ViewCountObj)['view_count']
  return new Response(String(viewCountVal))
}
</code></pre>
<p>对应的单测文件如下:</p>
<pre><code class="language-ts">/** /src/__test__/index.test.ts */
import { unstable_dev, type UnstableDevWorker } from 'wrangler'
import { describe, beforeAll, afterAll, it, expect } from 'vitest'

describe('Event Tracking', () =&gt; {
  let worker: UnstableDevWorker

  beforeAll(async () =&gt; {
    worker = await unstable_dev('src/index.ts', {
      experimental: { disableExperimentalWarning: true }
    })
  })

  afterAll(async () =&gt; {
    await worker?.stop()
  })

  // ...

  it('should return 200', async () =&gt; {
    const response = await worker.fetch('https://thorn.com/create/1701870426247')
    const code = response.status
    console.log(await response.text())
    expect(code).toBe(200)
  })
})
</code></pre>
<h1>部署</h1>
<p>首先将数据库创建 sql文件发布</p>
<pre><code class="language-bash">npx wrangler d1 execute event-tracking-db --file=./sql/schema.sql 
</code></pre>
<p>验证是否成功</p>
<pre><code class="language-bash">npx wrangler d1 execute event-tracking-db --command=&quot;SELECT * FROM view_tracking&quot;
</code></pre>
<p>不出意外会出现这玩意<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312151552033.png" alt="result image"><br>
最后发布你的 worker</p>
<pre><code class="language-bash">npx wrangler deploy
</code></pre>
<p>成功提示<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202312151618252.png" alt="success"></p>
<blockquote>
<p>本博客为服务端渲染, 客户端不会直接调用 worker 接口. 如果你的 app 是 spa, 请记得添加一些防刷操作和入参判断拦截.</p>
</blockquote>
]]></content:encoded>
            <author>songraysmail@gmail.com (Ray-D-Song)</author>
        </item>
        <item>
            <title><![CDATA[TailwindCSS 的价值]]></title>
            <link>https://ray-d-song.comsrc/page/post/value-of-tailwind.md</link>
            <guid>https://ray-d-song.comsrc/page/post/value-of-tailwind.md</guid>
            <pubDate>Wed, 11 Oct 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>tailwind 一直饱受非议, 其中说的最多的大概就是「我为什么不直接写内联样式?」.<br>
其实 tailwind 不仅是简写了样式名这么简单, 它是一系列便利的封装.</p>
<h1>动画</h1>
<p>举个简单的例子, <code>animate-spin</code> 属性用于添加旋转动画, 常用在 loading 中. 如果你用传统的 css/sass 编写, 那你至少需要以下代码.</p>
<pre><code class="language-css">animation: spin 1s linear infinite;

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</code></pre>
<h1>交互</h1>
<p>如果你希望一个 button 在鼠标炫富时颜色变浅, 在 tailwind 中只需要简单的<code>hover:opacity-90</code>, 传统的 css 则需要:</p>
<pre><code class="language-css">.btn:hover {
  background-color: rga(xxx,xxx,xxx, 0.9)
}
</code></pre>
<h1>响应式设计</h1>
<p>同时现代很多网页需要同时满足大屏设备和移动小屏设备的适配, 一般我们会用 css3 的 @media 来根据窗口尺寸编写不同的 css.</p>
<pre><code class="language-css">@media (max-width: 768px) {
  body {
    width: 80%
  }
}
</code></pre>
<p>在 tailwind 上, 适配 768px 宽度的设备, 你只要在样式前加入 <code>md</code> 前缀即可.</p>
<pre><code class="language-html">&lt;body class=&quot;md:w-4/5&quot;&gt;
</code></pre>
<h1>利好无设计开发</h1>
<p>个人或者小团队开发产品, 没有专业的设计师出图, 写组件相当痛苦.<br>
例如 box-shadow 属性, button、card、modal, 每个都需要不一样的 shadow 样式. 在自己编写的时候经常要重复修改多次来达到一个比较好的效果, twc 提供了 7 个不同规格的选项, 都是泛用性非常高的选择.<br>
现在你要写一个现代化外观的按钮只需要<code>class=&quot;shadow-md rounded-lg&quot;</code>就行了.</p>
<h1>新的组件模式</h1>
<p>tailwind 还有个衍生品, Headless UI. 将组件的功能和样式彻底分离. 很多时候组件的功能是相同的 , 但是需要不同的样式, 有时候样子一样的组件却需要完全不同的 api. Headless 就是为了解决这个问题.</p>
<blockquote>
<p>NuxtLab UI 就是一个无头tailwind组件库, 闲得蛋疼可以看看, 代码很干净.</p>
</blockquote>
<h1>class 也太特么长了</h1>
<p>这是一个由 tailwind 编写的 checkbox, 做了动效和深色适配.</p>
<pre><code class="language-html">&lt;input type=&quot;checkbox&quot; class=&quot;w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600&quot;/&gt;
</code></pre>
<p>看到这个长度是不是蚌埠住了. 没关系 tailwind 有<code>@layer</code>和<code>@apply</code>, 你可以像组织传统 css 一样去组织 tailwind, 封装自己的样式组件.</p>
<pre><code class="language-css">@layer components {
  .checkbox {
    @apply
    w-4
    h-4
    text-blue-600
    bg-gray-100
    border-gray-300
    rounded
    focus:ring-blue-500
    dark:focus:ring-blue-600
    dark:ring-offset-gray-800
    focus:ring-2
    dark:bg-gray-700
    dark:border-gray-600
  }
}
</code></pre>
<p>过长的样式导致的问题是无法避免的, 即便你直接写内联也是一样, 最终一定会回到封装样式组件的路上. 但之前所有的好处(抽象、减少代码量、响应式...)都还在.<br>
这也是一种「不过早抽象」的价值. 一个小的 idea, 你可以一把梭抢先实现原型, 后期再抽离维护, tailwind 降低了这一操作的难度.</p>
<blockquote>
<p>当然, 这种种好处的前提是, 要么你写风格多样化的 C 端界面, 要么需要创建属于自己团队的组件库. 然而很明显, 大多数公司还停留在<code>element antd</code>一把梭的阶段. 但这当然不是 tailwind 的问题.</p>
</blockquote>
<blockquote>
<p>实际上海外 <code>3T架构(Next tRPC Tailwind)</code> 已经火了有一阵了, 当然你也可以说这是前端瞎折腾, 但这确实是写出「现代、好看、交互强的界面」的捷径.</p>
</blockquote>
]]></content:encoded>
            <author>songraysmail@gmail.com (Ray-D-Song)</author>
        </item>
        <item>
            <title><![CDATA[协程(Coroutine)和纤程(Fiber)]]></title>
            <link>https://ray-d-song.comsrc/page/post/coroutine-and-fiber.md</link>
            <guid>https://ray-d-song.comsrc/page/post/coroutine-and-fiber.md</guid>
            <pubDate>Tue, 12 Sep 2023 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>最近在看 C++ 引入 Fiber 的<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf">N4024文档: 区分纤程和协程</a>, 文章给纤程和协程十分明确的区分. 但过去我看过的很多资料会将其混为一谈或者模糊二者的边界, 所以写了这篇博客来总结一下.</p>
<h1>纤程</h1>
<p>线程是一种轻量级的线程, 本质是对线程时间进行切片处理, 调度也由用户进行. 最早是 Microsoft 为了解决 Unix 平台的引用程序移植到 Windows 上时出现的问题而发起的提案.<br>
因此, 纤程是一种偏底层的概念, 通常由操作系统或runtime自动管理, 并不需要程序员手动干预. 例如 Windows 上的纤程就是在其内核上实现.</p>
<blockquote>
<p>值得注意的是, php8 引入的 Fiber 虽然叫做纤程, 其本质是协程.</p>
</blockquote>
<p>一个线程可以包含多个纤程, 纤程的好处是可以有效防止长时间的线程挂起. 例如在 IO 操作时, 实例化一个纤程进行 IO 操作, 在该纤程阻塞的过程中, 因为仅占用了一部分的时间切片, 程序依旧可以继续执行.</p>
<h1>协程</h1>
<p>协程的核心就是协作, 通过明确的挂起和恢复来控制执行的流程，使得不同任务之间可以更好地协同工作，共享信息，避免竞态条件，提高性能.<br>
协程在许多语言中都有实现, 例如 <code>Lua、Go、Ruby、Java(Virtual Threads)</code>, <code>Python 和 JavaScript(基于生成器)</code>.<br>
如果要用一句话来总结协程: <code>控制流的主动让出和恢复</code>.</p>
<h2>有栈协程和无栈协程</h2>
<p>协程有很多种, 按照多个协程之间是否存在调用栈, 可以分为<code>有栈协程(如goroutine、lua协程)</code>和<code>无栈协程(如JavaScript、Dart、Python)</code>.</p>
<blockquote>
<p>调用栈的作用是保存协程挂起时的状态.<br>
有栈协程在恢复时会将其上下文从栈内存中捞出恢复到系统栈中.<br>
无栈协程的挂起和恢复则依赖闭包和状态机实现.</p>
</blockquote>
<h2>对称协程和非对称协程</h2>
<p>非对称协程提供<code>两种控制操作</code>, <code>调用协程</code>和<code>挂起协程</code>. 非对称协程可以看做是其调用者的从属, 跟特定调用者绑定, 在让出控制权时, 只能回到原调用者.<br>
对称协程提供<code>单个控制操作</code>, 可以通过该操作在协程之间显示的传递控制权. 对称协程在启动后和原调用者就没什么关系了, 也因此, 对称协程需要一个调度器去选择转移控制权操作的目标协程.</p>
<h3>对称</h3>
<p>对称协程的例子非常少, 以下是 C++ <code>Boost.Coroutine</code> 的示例.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;coroutine&gt;

struct CountingCoroutine {
    struct promise_type {
        int current_value = 0;

        CountingCoroutine get_return_object() {
            return CountingCoroutine(std::coroutine_handle&lt;promise_type&gt;::from_promise(*this));
        }

        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() {}
        std::suspend_always yield_value(int value) {
            current_value = value;
            return {};
        }
    };

    std::coroutine_handle&lt;promise_type&gt; coroutine;

    CountingCoroutine(std::coroutine_handle&lt;promise_type&gt; handle) : coroutine(handle) {}

    ~CountingCoroutine() {
        if (coroutine)
            coroutine.destroy();
    }

    int getValue() const {
        return coroutine.promise().current_value;
    }

    void resume() {
        coroutine.resume();
    }
};

CountingCoroutine generateNumbers() {
    for (int i = 0; i &lt; 10; ++i) {
        //移交控制权
        co_yield i;
    }
}

int main() {
    CountingCoroutine counter = generateNumbers();

    while (counter.coroutine) {
        std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; counter.getValue() &lt;&lt; std::endl;
        //回到 co_yield 继续执行
        counter.resume();
    }

    return 0;
}
</code></pre>
<p>在 Go 语言中, 我们可以通过 chan 在没有特定从属关系的情况下完成协程间控制权的转移, 也算是对称协程的实现:</p>
<pre><code class="language-go">func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)

    var wg sync.WaitGroup

    wg.Add(1)
    go func() { // &lt;--- 1
        defer wg.Done()
        for val := range ch1 {
            fmt.Println(val)
        }
    }()

    wg.Add(1)
    go func() { // &lt;--- 2
        defer wg.Done()
        for val := range ch2 {
            ch1 &lt;- val
        }
        close(ch1)
    }()

    wg.Add(1)
    go func() { // &lt;--- 3
        defer wg.Done()
        for i := 1; i &lt;= 5; i++ {
            ch2 &lt;- i
        }
        close(ch2)
    }()

    wg.Wait()
}
</code></pre>
<p>如果按照代码的顺序执行, 那正确的排列顺序是 3 2 1, 但在此处由于channel的阻塞特性, 第一个goroutine会等待第二个goroutine将数据从 ch2 传输到 ch1, 而第二个goroutine会等待第三个goroutine将数据发送到 ch2, 这就保证了它们的执行顺序. 最后，当所有goroutine都完成并且WaitGroup计数为0时, wg.Wait() 返回, 程序退出.</p>
<h3>非对称</h3>
<p>JavaScript 的 async、await、promise 则是创建非对称协程的工具.</p>
<pre><code class="language-javascript">// async 标记的函数会创建协程
const useFetch = async () =&gt; { 
  // 执行到 await 处会将该协程挂起, 直到 fetch 返回
  const res = await fetch('https://www.v2ex.com/api/topics/hot.json')
  return res.json()
}

const main = () =&gt; {
  console.log('main start')
  // 执行到此处, 控制权转移到协程
  useFetch().then(res =&gt; { 
    // 执行到函数内部 await 处, 暂时挂起, 控制权返回到 main
    console.log(`fetch res: ${res}`)
  })
  console.log('main end')
}

main()
/**
 * main start
 * main end
 * fetch res: ...
 */
</code></pre>
<p>可以看到, 在 JS 中, 协程转移的控制权一定会返回到协程的调用者上.</p>
<h1>异同</h1>
<p>看到这里, 会发现纤程和协程极为相似.<br>
没错, 大框架上两者的基本概念是一样的. 仅有的区别是纤程的状态保存由操作系统API提供, 而协程保存和恢复的方式由语言或库提供, 背后的实现更是则多种多样.<br>
所以我们可以认为: 纤程实际上就是由操作系统提供的协程.<br>
参考<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf">Distinguishing coroutines and fibers</a>, 以下是一些细节的差别:</p>
<ol>
<li>Fiber 在发起后不再依赖于发起它的程序存在, 可以拥有独立的生命周期.<br>
Coroutine 作为发起者的「子程序」, 不存在独立的生命周期.</li>
<li>Fiber 和 Thread 行为模式基本一致. 存在一个调度器, 某个 Fiber 被阻塞, 会将控制权移交至调度器, 由调度器去唤起其他准备运行的 Fiber.<br>
对称协程的行为方式和 Fiber 基本一致. 非对称协程不存在调度器, 控制权会回到发起者.</li>
</ol>
]]></content:encoded>
            <author>songraysmail@gmail.com (Ray-D-Song)</author>
        </item>
        <item>
            <title><![CDATA[单线程并发]]></title>
            <link>https://ray-d-song.comsrc/page/post/single-thread-concurrency.md</link>
            <guid>https://ray-d-song.comsrc/page/post/single-thread-concurrency.md</guid>
            <pubDate>Wed, 16 Aug 2023 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<blockquote>
<p>本文封面和思路来源于 Ruby China 2021 By 东仙队长的分享: <a href="https://www.bilibili.com/video/BV1h3411v7kq/?spm_id_from=333.999.0.0&amp;vd_source=371668a779fa4a755fcbf62901a22d71">Ruby 高并发编程指北</a></p>
</blockquote>
<h1>并发</h1>
<p>假设有一个处理器, 因为只有一个核心, 所以同时他只能运行一个进程, 又因为一个进程上同一时间只能运行一个线程(task). 所以你可以认为, 同一时间, 这颗处理器只能处理一个任务.</p>
<p>操作系统会将<code>cpu 使用时间</code>这一资源进行切分, 这就是<code>时间分片</code>. 划分好的资源会按照调度算法分配给各个线程去使用. 进程内线程切换大概就是下面这种感觉:<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309091531790.png" alt="线程调度"></p>
<p>因为现代计算机性能足够强劲, 所以使用者体感上是 task_1、2、3 在同时运行, 这就是并发.</p>
<p>我并不想用<code>「多个任务同时发生」</code>这种模糊的表达, 在我看来<code>「并发」</code>之所以被称为<code>「并发」</code>单纯是翻译后中文表达的问题.<br>
<code>无论如何, 同时确实只有一个任务在进行</code></p>
<h1>并行</h1>
<p>并行就要好理解的多, 你有一个多核心处理器, 例如拥有两个核心的老古董E6600. 因为有两个核心, 同时能运行两个进程, 每个进程可以运行一个线程. 因此, 你的电脑就能真正的在同一时间运行两个任务.<br>
大概就是下面这种感觉:<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309091547730.png" alt="并行"></p>
<h1>程序设计</h1>
<p>之前刷知乎时, 看到这样一种说法:<code>「你的程序首先必须支持并发, 才能支持并行」</code><br>
因为并发不仅是对程序执行状态的一种描述, 也是一种程序设计的方法论:<br>
设计并发程序的条件就是<code>「程序的执行不依赖先后顺序、不依赖精确时序」</code>.<br>
而一段不依赖先后顺序、不依赖精确时序的程序, 自然可以拆分成多段, 在多个线程上运行. 这多个线程又可以运行在不同的进程之上, 进而实现<code>并行</code>.</p>
<p>首先我们来看看最常见的 web 应用场景, 从接收到用户请求到返回, 需要这些步骤:<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309092334861.png" alt="web app"><br>
其中<code>DB operation</code>占据了最大的空间, 因为数据库操作确实是最耗时的操作.</p>
<h1>多线程并发</h1>
<p>我们来假设一种极端的情况, 如果一直只有一个线程在运行, 那么运行过程就会变成这样:<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309092339287.png" alt="单线程"><br>
如果是这样的话, 我想我们这台单核的机器没几个用户就 burn out 了.<br>
应对这种情况, 最简单的思路就是多开几个线程, 虽然我们只有一个进程, 但当第一个线程卡在数据库操作时, 可以将控制权转移到其他线程进行操作.<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309092351360.png" alt="多线程"></p>
<h1>协程</h1>
<p>多线程并发, 一切看起来都很美好, 但有两个问题, 一个是计算机能启动的线程数量是有限的, 还有就是线程的切换有着客观的成本.<br>
那么如果我们可以自己在程序中<code>模拟线程</code>, 切换的不再是线程, 而是执行的程序方法. 岂不是可以用极低的成本去并发?<br>
这个模拟线程, 或者说<code>轻量线程/用户线程</code>, 就是协程.<br>
有了协程, 我们可以更细粒度的控制程序的执行. 以下是 node.js 协程(async异步)的例子:</p>
<pre><code class="language-js">async function App(request, response) {
  const id = request.query.id // &lt;- read req and parsing
  try {
    const result = await DB.find({ id }) // &lt;- DB operation
    res.json({ // generate json and response
      code: 200,
      data: result
    })
  } catch(e) {
    // ...
  }
}
</code></pre>
<p>当程序执行到<code>await</code>标识的数据库操作时, 就会在当前方法内形成阻塞, 等待数据库的返回结果. 但对于调用 App() 的方法来说, 程序则会继续向下执行(处理其他的请求).</p>
<p>整个过程的简略图大概如下:<br>
<img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309101809693.png" alt="async"></p>
<p>关于协程更具体的介绍, 可以看我的这篇文章<a href="https://ray-d-song.com/post/1692667782462">协程(Coroutine)和纤程(Fiber)</a></p>
<p>实际上这种<code>单线程+协程</code>并发模型, 就是 Node.js 的并发模型.<br>
这几年协程的火爆, jdk21、php8 都支持了协程方案. 足以提现这种模式的优势.</p>
<blockquote>
<p>说到这里, 有没有什么比单线程异步并发更强的方案呢?<br>
那就是<code>多线程+协程</code>, Go 就是这样的方案. Go 实现了一种更复杂的 Goroutine 到实际线程资源的映射, 使其可以以极低的配置达到恐怖的并发性能</p>
</blockquote>
]]></content:encoded>
            <author>songraysmail@gmail.com (Ray-D-Song)</author>
        </item>
    </channel>
</rss>