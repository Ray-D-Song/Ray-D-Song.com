import{_ as a}from"./copy-D7w4FOSZ.js";import{b as i,o as n,h as t}from"./index-5jwLyAdA.js";const o={class:"markdown-body"},e=t('<blockquote><p>本文封面和思路来源于 Ruby China 2021 By 东仙队长的分享: <a href="https://www.bilibili.com/video/BV1h3411v7kq/?spm_id_from=333.999.0.0&amp;vd_source=371668a779fa4a755fcbf62901a22d71">Ruby 高并发编程指北</a></p></blockquote><h1>并发</h1><p>假设有一个处理器, 因为只有一个核心, 所以同时他只能运行一个进程, 又因为一个进程上同一时间只能运行一个线程(task). 所以你可以认为, 同一时间, 这颗处理器只能处理一个任务.</p><p>操作系统会将<code>cpu 使用时间</code>这一资源进行切分, 这就是<code>时间分片</code>. 划分好的资源会按照调度算法分配给各个线程去使用. 进程内线程切换大概就是下面这种感觉: <img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309091531790.png" alt="线程调度"></p><p>因为现代计算机性能足够强劲, 所以使用者体感上是 task_1、2、3 在同时运行, 这就是并发.</p><p>我并不想用<code>「多个任务同时发生」</code>这种模糊的表达, 在我看来<code>「并发」</code>之所以被称为<code>「并发」</code>单纯是翻译后中文表达的问题.<br><code>无论如何, 同时确实只有一个任务在进行</code></p><h1>并行</h1><p>并行就要好理解的多, 你有一个多核心处理器, 例如拥有两个核心的老古董E6600. 因为有两个核心, 同时能运行两个进程, 每个进程可以运行一个线程. 因此, 你的电脑就能真正的在同一时间运行两个任务.<br> 大概就是下面这种感觉: <img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309091547730.png" alt="并行"></p><h1>程序设计</h1><p>之前刷知乎时, 看到这样一种说法:<code>「你的程序首先必须支持并发, 才能支持并行」</code><br> 因为并发不仅是对程序执行状态的一种描述, 也是一种程序设计的方法论:<br> 设计并发程序的条件就是<code>「程序的执行不依赖先后顺序、不依赖精确时序」</code>.<br> 而一段不依赖先后顺序、不依赖精确时序的程序, 自然可以拆分成多段, 在多个线程上运行. 这多个线程又可以运行在不同的进程之上, 进而实现<code>并行</code>.</p><p>首先我们来看看最常见的 web 应用场景, 从接收到用户请求到返回, 需要这些步骤: <img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309092334861.png" alt="web app"> 其中<code>DB operation</code>占据了最大的空间, 因为数据库操作确实是最耗时的操作.</p><h1>多线程并发</h1><p>我们来假设一种极端的情况, 如果一直只有一个线程在运行, 那么运行过程就会变成这样: <img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309092339287.png" alt="单线程"> 如果是这样的话, 我想我们这台单核的机器没几个用户就 burn out 了. 应对这种情况, 最简单的思路就是多开几个线程, 虽然我们只有一个进程, 但当第一个线程卡在数据库操作时, 可以将控制权转移到其他线程进行操作. <img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309092351360.png" alt="多线程"></p><h1>协程</h1><p>多线程并发, 一切看起来都很美好, 但有两个问题, 一个是计算机能启动的线程数量是有限的, 还有就是线程的切换有着客观的成本. 那么如果我们可以自己在程序中<code>模拟线程</code>, 切换的不再是线程, 而是执行的程序方法. 岂不是可以用极低的成本去并发? 这个模拟线程, 或者说<code>轻量线程/用户线程</code>, 就是协程. 有了协程, 我们可以更细粒度的控制程序的执行. 以下是 node.js 协程(async异步)的例子:</p><pre class="shiki shiki-themes rose-pine-dawn tokyo-night" style="background-color:#faf4ed;--shiki-dark-bg:#1a1b26;color:#575279;--shiki-dark:#a9b1d6;" tabindex="0"><div class="copy-container"><div class="lang-symbol">js</div><img src="'+a+`" class="copy-icon" data-code="async function App(request, response) {
  const id = request.query.id // &lt;- read req and parsing
  try {
    const result = await DB.find({ id }) // &lt;- DB operation
    res.json({ // generate json and response
      code: 200,
      data: result
    })
  } catch(e) {
    // ...
  }
}
"></div><code><span class="line"><span style="color:#286983;--shiki-dark:#9D7CD8;font-style:inherit;--shiki-dark-font-style:italic;">async</span><span style="color:#286983;--shiki-dark:#BB9AF7;"> function</span><span style="color:#D7827E;--shiki-dark:#7AA2F7;"> App</span><span style="color:#797593;--shiki-dark:#9ABDF5;">(</span><span style="color:#907AA9;--shiki-dark:#E0AF68;font-style:italic;--shiki-dark-font-style:inherit;">request</span><span style="color:#797593;--shiki-dark:#89DDFF;">,</span><span style="color:#907AA9;--shiki-dark:#E0AF68;font-style:italic;--shiki-dark-font-style:inherit;"> response</span><span style="color:#797593;--shiki-dark:#9ABDF5;">)</span><span style="color:#797593;--shiki-dark:#9ABDF5;"> {</span></span>
<span class="line"><span style="color:#286983;--shiki-dark:#9D7CD8;font-style:inherit;--shiki-dark-font-style:italic;">  const</span><span style="color:#575279;--shiki-dark:#BB9AF7;font-style:italic;--shiki-dark-font-style:inherit;"> id</span><span style="color:#286983;--shiki-dark:#89DDFF;"> =</span><span style="color:#575279;--shiki-dark:#C0CAF5;font-style:italic;--shiki-dark-font-style:inherit;"> request</span><span style="color:#286983;--shiki-dark:#89DDFF;">.</span><span style="color:#575279;--shiki-dark:#C0CAF5;font-style:italic;--shiki-dark-font-style:inherit;">query</span><span style="color:#286983;--shiki-dark:#89DDFF;">.</span><span style="color:#575279;--shiki-dark:#7DCFFF;font-style:italic;--shiki-dark-font-style:inherit;">id</span><span style="color:#797593;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;"> //</span><span style="color:#9893A5;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;"> &lt;- read req and parsing</span></span>
<span class="line"><span style="color:#286983;--shiki-dark:#BB9AF7;">  try</span><span style="color:#797593;--shiki-dark:#9ABDF5;"> {</span></span>
<span class="line"><span style="color:#286983;--shiki-dark:#9D7CD8;font-style:inherit;--shiki-dark-font-style:italic;">    const</span><span style="color:#575279;--shiki-dark:#BB9AF7;font-style:italic;--shiki-dark-font-style:inherit;"> result</span><span style="color:#286983;--shiki-dark:#89DDFF;"> =</span><span style="color:#286983;--shiki-dark:#BB9AF7;font-style:inherit;--shiki-dark-font-style:italic;"> await</span><span style="color:#575279;--shiki-dark:#0DB9D7;font-style:italic;--shiki-dark-font-style:inherit;"> DB</span><span style="color:#286983;--shiki-dark:#89DDFF;">.</span><span style="color:#D7827E;--shiki-dark:#7AA2F7;">find</span><span style="color:#575279;--shiki-dark:#9ABDF5;">(</span><span style="color:#797593;--shiki-dark:#9ABDF5;">{</span><span style="color:#575279;--shiki-dark:#C0CAF5;font-style:italic;--shiki-dark-font-style:inherit;"> id</span><span style="color:#797593;--shiki-dark:#9ABDF5;"> }</span><span style="color:#575279;--shiki-dark:#9ABDF5;">) </span><span style="color:#797593;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;">//</span><span style="color:#9893A5;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;"> &lt;- DB operation</span></span>
<span class="line"><span style="color:#575279;--shiki-dark:#C0CAF5;font-style:italic;--shiki-dark-font-style:inherit;">    res</span><span style="color:#286983;--shiki-dark:#89DDFF;">.</span><span style="color:#D7827E;--shiki-dark:#7AA2F7;">json</span><span style="color:#575279;--shiki-dark:#9ABDF5;">(</span><span style="color:#797593;--shiki-dark:#9ABDF5;">{</span><span style="color:#797593;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;"> //</span><span style="color:#9893A5;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;"> generate json and response</span></span>
<span class="line"><span style="color:#575279;--shiki-dark:#73DACA;">      code</span><span style="color:#797593;--shiki-dark:#89DDFF;">:</span><span style="color:#D7827E;--shiki-dark:#FF9E64;"> 200</span><span style="color:#797593;--shiki-dark:#89DDFF;">,</span></span>
<span class="line"><span style="color:#575279;--shiki-dark:#73DACA;">      data</span><span style="color:#797593;--shiki-dark:#89DDFF;">:</span><span style="color:#575279;--shiki-dark:#C0CAF5;font-style:italic;--shiki-dark-font-style:inherit;"> result</span></span>
<span class="line"><span style="color:#797593;--shiki-dark:#9ABDF5;">    }</span><span style="color:#575279;--shiki-dark:#9ABDF5;">)</span></span>
<span class="line"><span style="color:#797593;--shiki-dark:#9ABDF5;">  }</span><span style="color:#286983;--shiki-dark:#BB9AF7;"> catch</span><span style="color:#575279;--shiki-dark:#9ABDF5;">(</span><span style="color:#575279;--shiki-dark:#C0CAF5;font-style:italic;--shiki-dark-font-style:inherit;">e</span><span style="color:#575279;--shiki-dark:#9ABDF5;">) </span><span style="color:#797593;--shiki-dark:#9ABDF5;">{</span></span>
<span class="line"><span style="color:#797593;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;">    //</span><span style="color:#9893A5;--shiki-dark:#51597D;font-style:italic;--shiki-dark-font-style:italic;"> ...</span></span>
<span class="line"><span style="color:#797593;--shiki-dark:#9ABDF5;">  }</span></span>
<span class="line"><span style="color:#797593;--shiki-dark:#9ABDF5;">}</span></span>
<span class="line"></span></code></pre><p>当程序执行到<code>await</code>标识的数据库操作时, 就会在当前方法内形成阻塞, 等待数据库的返回结果. 但对于调用 App() 的方法来说, 程序则会继续向下执行(处理其他的请求).</p><p>整个过程的简略图大概如下: <img src="https://pic-base-1307984077.cos.ap-nanjing.myqcloud.com/202309101809693.png" alt="async"></p><p>关于协程更具体的介绍, 可以看我的这篇文章<a href="https://ray-d-song.com/post/1692667782462">协程(Coroutine)和纤程(Fiber)</a></p><p>实际上这种<code>单线程+协程</code>并发模型, 就是 Node.js 的并发模型. 这几年协程的火爆, jdk21、php8 都支持了协程方案. 足以提现这种模式的优势.</p><blockquote><p>说到这里, 有没有什么比单线程异步并发更强的方案呢? 那就是<code>多线程+协程</code>, Go 就是这样的方案. Go 实现了一种更复杂的 Goroutine 到实际线程资源的映射, 使其可以以极低的配置达到恐怖的并发性能</p></blockquote>`,21),l=[e],y="单线程并发",f="小短文, 讨论单线程并发和 node.js 这样异步协程模型的优势",D="2023-8-17",F={__name:"single-thread-concurrency",setup(r,{expose:s}){return s({frontmatter:{title:"单线程并发",intro:"小短文, 讨论单线程并发和 node.js 这样异步协程模型的优势",time:"2023-8-17"}}),(c,k)=>(n(),i("div",o,l))}};export{F as default,f as intro,D as time,y as title};
